import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as e}from"./app-DS0ZCcmM.js";const l={};function t(p,s){return e(),n("div",null,s[0]||(s[0]=[a(`<h1 id="k8s入门" tabindex="-1"><a class="header-anchor" href="#k8s入门"><span>k8s入门</span></a></h1><h2 id="部署应用程序" tabindex="-1"><a class="header-anchor" href="#部署应用程序"><span>部署应用程序</span></a></h2><p>K8S通过发布Deployment来进行程序的部署</p><blockquote><p><strong>Deployment</strong> 译名为 <strong>部署</strong>。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</p></blockquote><p>创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></p><h3 id="通过kubectl部署nginx" tabindex="-1"><a class="header-anchor" href="#通过kubectl部署nginx"><span>通过kubectl部署nginx</span></a></h3><p>Deployment通过yaml文件指定，因此我们只需要写一个容器文件即可</p><blockquote><p>感觉和docker compose的文件比较像</p></blockquote><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">apiVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">apps/v1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #取决于k8s支持的集群版本</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Deployment</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #该配置的类型，我们使用的是 Deployment</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#下方用来定义Deplyment一些基本属性</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx-deployment</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #Deployment名车给</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  labels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#标签，为key: value</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#关于Deployment的描述</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  replicas</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #运行的所需 Pod 的数量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  selector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#标签选择器，与上面的标签共同作用</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    matchLabels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#这是选择或创建的Pod的模板</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      labels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#期望Pod实现的功能（即在pod中部署）</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      containers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#生成的容器，我们采用的服务为docker，因此为docker创建的容器</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #容器名称</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        image</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx:1.7.9</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #指定使用的镜像</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        ports</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">containerPort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">80</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #设置容器使用的端口</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>还有一些其他参数</p><ul><li><p>replicas： 控制着运行的所需 Pod 的数量</p></li><li><p>template： 为 Deployment 创建的 Pod 提供模板</p></li><li><p>selector： 用于找出由 Deployment 管辨理的 Pod</p></li><li><p>strategy： 提供更新 Deployment 的策略</p><p>具体可以参考<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener noreferrer">Kubernetes Deployment 详细介绍</a></p></li></ul></blockquote><p>执行命令应用该Deployment</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kubectl apply -f nginx-deployment.yaml</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在你应该能看到一个名为nginx-deployment的Deployment和一个名为 nginx-deployment-xxxxxxx-xxxxx 的 Pod</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240118204836958.png" alt="image-20240118204836958" tabindex="0" loading="lazy"><figcaption>image-20240118204836958</figcaption></figure><p>用图形化界面进行部署会更加简单</p><h2 id="pods-nodes" tabindex="-1"><a class="header-anchor" href="#pods-nodes"><span>Pods&amp;Nodes</span></a></h2><h3 id="pods" tabindex="-1"><a class="header-anchor" href="#pods"><span>Pods</span></a></h3><p>创建Deployment之后，k8s创建了一个pod（容器组）用来存储应用实例</p><p><strong>Pod 容器组</strong> 是一个k8s中一个抽象的概念，用于存放一组 container（可包含一个或多个 container 容器，即图上正方体)，以及这些 container （容器）的一些共享资源。这些资源包括：</p><ul><li>共享存储，称为卷(Volumes)</li><li>网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址</li><li>container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等</li></ul><blockquote><p>同一pod中，不一致只有一个服务，例如服务A需要服务B提供数据，由于同一pod中IP地址是共享的，因此服务A想要访问服务B，需要通过localhost+port的形式进行访问(同一pod中，containers的ports不能产生冲突)</p></blockquote><p>通过Deployment创建的pod，在该pod对应的worker所在的节点(Node)发生故障时，会在集群的其他可用Node上运行相同的Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同）</p><blockquote><p>学到这里先提个问题：ip不同，pod名字不同，那么如果是需要固定的服务该怎么进行访问？到底会不会存在这样的问题？和docker使用自定义网络的形式相同吗？</p></blockquote><ul><li>重要提示： <ul><li>Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。</li><li>如果多个容器紧密耦合并且需要共享磁盘等资源，则他们应该被部署在同一个Pod（容器组）中。</li></ul></li></ul><h3 id="nodes" tabindex="-1"><a class="header-anchor" href="#nodes"><span>Nodes</span></a></h3><p>Pod是依赖于节点运行的，一个节点上可以有多个pod。</p><p>Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。</p><p>kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。</p><p>每个 Kubernetes Node（节点）至少运行：</p><ul><li>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。</li><li>容器运行环境（如Docker）负责下载镜像、创建和运行容器等。</li></ul><h2 id="公布应用程序" tabindex="-1"><a class="header-anchor" href="#公布应用程序"><span>公布应用程序</span></a></h2><h3 id="kubernetes-service-服务-概述" tabindex="-1"><a class="header-anchor" href="#kubernetes-service-服务-概述"><span>Kubernetes Service（服务）概述</span></a></h3><p>我们知道当pod运行的Node故障时，Deployment可以通过创建新的Pod来动态地将群集调整回原来的状态，以使应用程序保持运行。</p><p>但是在这个过程中pod的ip和name发生了变化。由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p><blockquote><p>这部分正好解决前面提出的问题</p></blockquote><p>Service API 是 Kubernetes 的组成部分，它是一种抽象，帮助你将 Pod 集合在网络上公开出去。 每个 Service 对象定义端点的一个逻辑集合（通常这些端点就是 Pod）以及如何访问到这些 Pod 的策略。</p><p>Service（服务）使 Pod（容器组）之间的相互依赖解耦（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）。一个 Service（服务）选定哪些 <strong>Pod（容器组）</strong> 通常由 <strong>LabelSelector(标签选择器)</strong> 来决定。</p><p>通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序：</p><ul><li><p><strong>ClusterIP</strong>（默认）</p><p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong></p><p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong></p><p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><h3 id="服务和标签" tabindex="-1"><a class="header-anchor" href="#服务和标签"><span>服务和标签</span></a></h3><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240119134252039.png" alt="image-20240119134252039" tabindex="0" loading="lazy"><figcaption>image-20240119134252039</figcaption></figure><p>这里用kuboard的图片，方便理解学习</p><p>Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态调度容器组（在容器组失效后重新创建容器组，增加或者减少同一个 Deployment 对应容器组的数量等）</p><blockquote><p>意思是在node在down以后，对于新建的pod，仍然位于服务中，解决了之前的问题</p><p>那么我们该如何确定服务位置，以及服务的所包含的pod呢？</p></blockquote><p>Service使用 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" target="_blank" rel="noopener noreferrer">Labels、LabelSelector(标签和选择器) (opens new window)</a>匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键/值对，其用途有多种：</p><ul><li>将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境</li><li>嵌入版本标签，使用标签区别不同应用软件版本</li><li>使用标签对 Kubernetes 对象进行分类</li></ul><p>对于上图</p><ul><li>Deployment B 含有 LabelSelector 为 app=B 通过此方式声明含有 app=B 标签的 Pod 与之关联</li><li>通过 Deployment B 创建的 Pod 包含标签为 app=B</li><li>Service B 通过标签选择器 app=B 选择可以路由的 Pod</li></ul><blockquote><p>包含的关系，service通过标签选择器来选择pod</p></blockquote><h3 id="为nginx-deployment创建服务" tabindex="-1"><a class="header-anchor" href="#为nginx-deployment创建服务"><span>为nginx-deployment创建服务</span></a></h3><p>我们之前所用的文件如下</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:	</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#译名为元数据，即Deployment的一些基本属性和信息</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx-deployment</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	#Deployment的名称</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  labels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:	</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	#为该Deployment设置key为app，value为nginx的标签</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>通过该deployment创建的pod,都含有app=nginx这个标签</p></blockquote><p>现在我们创建一个nginx-service.yaml文件来配置该deployment的服务</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">apiVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">v1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Service</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> 	#类型为Service</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx-service</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #服务名称</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  labels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  #Service 自己的标签</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  selector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#标签选择器配置</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  #包含标签app: nginx的pod</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  ports</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx-port</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #端口名字</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    protocol</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">TCP</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #协议</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">80</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #集群内的其他容器组可通过 80 端口访问 Service </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    nodePort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32600</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #通过任意节点的 32600 端口访问 Service</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    targetPort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">80</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #将请求转发到匹配 Pod 的 80 端口</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">NodePort</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行命令</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kubectl apply -f nginx-service.yaml</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在我们可以通过任意一个node来访问nginx服务</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240119141728198.png" alt="image-20240119141728198" tabindex="0" loading="lazy"><figcaption>image-20240119141728198</figcaption></figure><blockquote><p>或许单纯这样看配置文件并不好理解端口的映射关系，以及为什么能够从任意一个Node去访问服务</p><ol><li><code>port</code>：这是服务的公开端口，集群中的其他Pod通过此端口访问该服务。示例中，其他Pod可以通过80端口访问该服务。</li><li><code>nodePort</code>：这是你的服务在节点上的公开端口。这意味着服务可以通过这个端口在集群外部访问。示例中，可以通过任何节点的32600端口访问该服务。</li><li><code>targetPort</code>：这是服务将流量转发到的Pod内的端口。示例中，请求将被转发到匹配Pod的80端口。</li><li><code>NodePort</code>：这代表服务在每个节点的一个静态端口（nodePort）上暴露出来。你可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群的外部访问这个服务。</li></ol></blockquote><p>当然一个服务不可能只有一个端口，也不一定只有一个pod,如下，对服务设置多端口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>apiVersion: v1</span></span>
<span class="line"><span>kind: Service</span></span>
<span class="line"><span>metadata:</span></span>
<span class="line"><span>  name: my-service</span></span>
<span class="line"><span>spec:</span></span>
<span class="line"><span>  selector:</span></span>
<span class="line"><span>    app.kubernetes.io/name: MyApp</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>    - name: http</span></span>
<span class="line"><span>      protocol: TCP</span></span>
<span class="line"><span>      port: 80</span></span>
<span class="line"><span>      targetPort: 9376</span></span>
<span class="line"><span>    - name: https</span></span>
<span class="line"><span>      protocol: TCP</span></span>
<span class="line"><span>      port: 443</span></span>
<span class="line"><span>      targetPort: 9377</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为 Service 使用多个端口时，必须为所有端口提供名称，以使它们无歧义</strong></p><blockquote><p>Pod 中的端口定义是有名字的，你可以在 Service 的 <code>targetPort</code> 属性中引用这些名字</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">apiVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">v1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Pod</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  labels</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app.kubernetes.io/name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">proxy</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  containers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    image</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx:stable</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    ports</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">containerPort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">80</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">http-web-svc</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">---</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">apiVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">v1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Service</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">nginx-service</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  selector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    app.kubernetes.io/name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">proxy</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  ports</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  - </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">name-of-service-port</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    protocol</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">TCP</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    port</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">80</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    targetPort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">http-web-svc</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h2 id="伸缩应用程序" tabindex="-1"><a class="header-anchor" href="#伸缩应用程序"><span>伸缩应用程序</span></a></h2><h3 id="scaling-伸缩-应用程序" tabindex="-1"><a class="header-anchor" href="#scaling-伸缩-应用程序"><span>Scaling（伸缩）应用程序</span></a></h3><p>对于出现较大流量时采用的策略，<strong>伸缩</strong> 的实现可以通过更改 nginx-deployment.yaml 文件中部署的 replicas（副本数）来完成</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>spec:</span></span>
<span class="line"><span>  replicas: 2    #使用该Deployment创建两个应用程序实例</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这样做的好处是，外部在访问service服务时，会将流量转发到多个负载上减轻压力</p></blockquote><h2 id="执行滚动更新" tabindex="-1"><a class="header-anchor" href="#执行滚动更新"><span>执行滚动更新</span></a></h2><p><strong>Rolling Update滚动更新</strong> 通过使用新版本的 Pod 逐步替代旧版本的 Pod 来实现 Deployment 的更新，从而实现零停机。新的 Pod 将在具有可用资源的 Node（节点）上进行调度。</p><blockquote><p>Kubernetes 更新多副本的 Deployment 的版本时，会逐步的创建新版本的 Pod，逐步的停止旧版本的 Pod，以便使应用一直处于可用状态。这个过程中，Service 能够监视 Pod 的状态，将流量始终转发到可用的 Pod 上。</p><p>(显然这样更新，deployment创建实例不能为1)</p></blockquote><p>默认情况下，<strong>Rolling Update 滚动更新</strong> 过程中，Kubernetes 逐个使用新版本 Pod 替换旧版本 Pod（最大不可用 Pod 数为 1、最大新建 Pod 数也为 1）。这两个参数可以配置为数字或百分比。在Kubernetes 中，更新是版本化的，任何部署更新都可以恢复为以前的（稳定）版本。</p><blockquote><p>简单来说，创一替一，注意新建的pod拥有一个新的ip</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>apiVersion: apps/v1</span></span>
<span class="line"><span>kind: Deployment</span></span>
<span class="line"><span>metadata:</span></span>
<span class="line"><span>  name: nginx-deployment</span></span>
<span class="line"><span>  labels:</span></span>
<span class="line"><span>    app: nginx</span></span>
<span class="line"><span>spec:</span></span>
<span class="line"><span>  replicas: 2</span></span>
<span class="line"><span>  selector:</span></span>
<span class="line"><span>    matchLabels:</span></span>
<span class="line"><span>      app: nginx</span></span>
<span class="line"><span>  template:</span></span>
<span class="line"><span>    metadata:</span></span>
<span class="line"><span>      labels:</span></span>
<span class="line"><span>        app: nginx</span></span>
<span class="line"><span>    spec:</span></span>
<span class="line"><span>      containers:</span></span>
<span class="line"><span>      - name: nginx</span></span>
<span class="line"><span>        image: nginx:1.8.0 #替换为新版本</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kubectl apply -f nginx-deployment.yaml</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>随后开始滚动更新</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>watch kubectl get pods -l app=nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用该命令可以看到更新的整个过程</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2><p><a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">kubernetes</a></p><p><a href="https://kuboard.cn/learning/k8s-bg/architecture/com-m-n.html#apiserver-to-kubelet" target="_blank" rel="noopener noreferrer">kuboard</a></p>`,83)]))}const d=i(l,[["render",t],["__file","K8s入门.html.vue"]]),r=JSON.parse('{"path":"/%E4%BA%91/K8S/K8s%E5%85%A5%E9%97%A8.html","title":"k8s入门","lang":"zh-CN","frontmatter":{"description":"k8s入门 部署应用程序 K8S通过发布Deployment来进行程序的部署 Deployment 译名为 部署。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 Pod 的概念中，Pod 是 k8s 中最小可管理单元。 创建应用程序实例后，...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E4%BA%91/K8S/K8s%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"k8s入门"}],["meta",{"property":"og:description","content":"k8s入门 部署应用程序 K8S通过发布Deployment来进行程序的部署 Deployment 译名为 部署。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 Pod 的概念中，Pod 是 k8s 中最小可管理单元。 创建应用程序实例后，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240118204836958.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"k8s入门\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240118204836958.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240119134252039.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240119141728198.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"部署应用程序","slug":"部署应用程序","link":"#部署应用程序","children":[{"level":3,"title":"通过kubectl部署nginx","slug":"通过kubectl部署nginx","link":"#通过kubectl部署nginx","children":[]}]},{"level":2,"title":"Pods&Nodes","slug":"pods-nodes","link":"#pods-nodes","children":[{"level":3,"title":"Pods","slug":"pods","link":"#pods","children":[]},{"level":3,"title":"Nodes","slug":"nodes","link":"#nodes","children":[]}]},{"level":2,"title":"公布应用程序","slug":"公布应用程序","link":"#公布应用程序","children":[{"level":3,"title":"Kubernetes Service（服务）概述","slug":"kubernetes-service-服务-概述","link":"#kubernetes-service-服务-概述","children":[]},{"level":3,"title":"服务和标签","slug":"服务和标签","link":"#服务和标签","children":[]},{"level":3,"title":"为nginx-deployment创建服务","slug":"为nginx-deployment创建服务","link":"#为nginx-deployment创建服务","children":[]}]},{"level":2,"title":"伸缩应用程序","slug":"伸缩应用程序","link":"#伸缩应用程序","children":[{"level":3,"title":"Scaling（伸缩）应用程序","slug":"scaling-伸缩-应用程序","link":"#scaling-伸缩-应用程序","children":[]}]},{"level":2,"title":"执行滚动更新","slug":"执行滚动更新","link":"#执行滚动更新","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":10.26,"words":3078},"filePathRelative":"云/K8S/K8s入门.md","localizedDate":"2025年1月16日","excerpt":"\\n<h2>部署应用程序</h2>\\n<p>K8S通过发布Deployment来进行程序的部署</p>\\n<blockquote>\\n<p><strong>Deployment</strong> 译名为 <strong>部署</strong>。在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</p>\\n</blockquote>\\n<p>创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></p>","autoDesc":true}');export{d as comp,r as data};
