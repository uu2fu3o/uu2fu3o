import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as a}from"./app-DS0ZCcmM.js";const s={};function r(p,e){return a(),t("div",null,e[0]||(e[0]=[n(`<h1 id="ntlm签名" tabindex="-1"><a class="header-anchor" href="#ntlm签名"><span>NTLM签名</span></a></h1><p>这一篇主要是讲讲为了防止ntlm relay而做的一些防护措施即签名问题。</p><h2 id="签名方式" tabindex="-1"><a class="header-anchor" href="#签名方式"><span>签名方式</span></a></h2><p>简单来说客户端会和服务端商量使用哪一串字符进行加密，如果我们得不到这串字符，就只能进行流量的转发，而无法进行relay</p><p>签名的整个过程中有3个key</p><h4 id="exported-session-key" tabindex="-1"><a class="header-anchor" href="#exported-session-key"><span>exported_session_key</span></a></h4><p>如下该key的加密规则</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get_random_export_session_key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> os.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">urandom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个key是随机数。如果开启签名的话，客户端和服务端是用这个做为key进行签名的。</p><h4 id="key-exchange-key" tabindex="-1"><a class="header-anchor" href="#key-exchange-key"><span>key_exchange_key</span></a></h4><p>这个key使用用户密码，Server Challenge,Client Challenge经过一定运算得到(借鉴师傅的图)</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/t01f6642281b8157af5.png" alt="t01f6642281b8157af5" tabindex="0" loading="lazy"><figcaption>t01f6642281b8157af5</figcaption></figure><h4 id="encrypted-random-session-key" tabindex="-1"><a class="header-anchor" href="#encrypted-random-session-key"><span>encrypted_random_session_key</span></a></h4><p>当开启签名时，会使用exported_session_key作为密钥，并且使用key_exchange_key与之运算得到encrypted_random_session_key</p><p>具体的加密流程如下：</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/jiami.png" alt="jiami" tabindex="0" loading="lazy"><figcaption>jiami</figcaption></figure><p>服务端得到encrypted_random_session_key后，与key_exchange_key再次进行运算，得到随机数key,encrypted_random_session_key这个session_key在流量中是明文显示的，我们可以得到，但即便如此，我们也无法对其进行利用，，因为我们没办法拿到key_session_key，就没法得到随机key,也就无法对流量进行加解密，也就不能进行relay</p><h2 id="smb签名" tabindex="-1"><a class="header-anchor" href="#smb签名"><span>SMB签名</span></a></h2><p>在一个默认的域环境中，域控制器开启smb签名，域成员机器并没有开启</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/smb.png" alt="smb" tabindex="0" loading="lazy"><figcaption>smb</figcaption></figure><p>（在实际测试时我的域控制器实际上并没有启用这个选项）</p><h2 id="ldap签名" tabindex="-1"><a class="header-anchor" href="#ldap签名"><span>LDAP签名</span></a></h2><p>在默认情况底下，ldap服务器就在域控里面，而且默认策略就是协商签名。而不是强制签名。也就是说是否签名是有客户端决定的。服务端跟客户端协商是否签名。(客户端分情况，如果是smb协议的话，默认要求签名的，如果是webadv或者http协议，是不要求签名的)</p><p>微软公司于 2019-09-11 日发布相关通告称微软计划于 2020 年 1 月发布安全更新。为了提升域控制器的安全性，该安全更新将强制开启所有域控制器上 LDAP channel binding 与 LDAP signing 功能。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ldap.png" alt="ldap" tabindex="0" loading="lazy"><figcaption>ldap</figcaption></figure><h2 id="smb签名流量分析" tabindex="-1"><a class="header-anchor" href="#smb签名流量分析"><span>SMB签名流量分析</span></a></h2><p>接下来抓取具体的流量对SMB签名进行简单分析，有助于理解这个过程</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/smb2.png" alt="smb2" tabindex="0" loading="lazy"><figcaption>smb2</figcaption></figure><p>上图为服务端向客户端返回chanllege阶段，在这个过程中是不需要签名的，签名是针对会话产生，在会话过程中之前如何确定两个服务器之间的会话是否需要签名，这一步在<strong>NTLM协商期间完成</strong>，二是允许指示签名是<strong>必需的</strong>、<strong>可选的</strong>还是<strong>禁用的</strong>。这是在客户端和服务器级别完成的设置。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/askkk1.png" alt="askkk1" tabindex="0" loading="lazy"><figcaption>askkk1</figcaption></figure><p>如图的flag标识位，当flag值为1时，标识客户端支持签名，但这并不意味着一定要使用签名，同理服务端也是这样。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/enables.png" alt="enables" tabindex="0" loading="lazy"><figcaption>enables</figcaption></figure><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/origin.png" alt="origin" tabindex="0" loading="lazy"><figcaption>origin</figcaption></figure><p>这段信息来源于标记部分，是在最初的地方对SMB签名进行了标识，PC表示不需要签名，但是它可以处理带签名的数据包</p><p>同理可以查看DC</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/respoinse.png" alt="respoinse" tabindex="0" loading="lazy"><figcaption>respoinse</figcaption></figure><p>DC表示不仅支持签名，而且需要签名，此后会话过程中的SMB数据包将会被签名。</p><p>另外一些细节会在相关漏洞中提到。</p><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接：</span></a></h3><p><a href="https://daiker.gitbook.io/windows-protocol/ntlm-pian/7#1.-guan-yu-qian-ming-de-yi-dian-xi-jie" target="_blank" rel="noopener noreferrer">windows protocol</a></p><p><a href="https://www.geekby.site/2021/09/ntlm-relay/#43-smb--ntlm" target="_blank" rel="noopener noreferrer">ntlm relay</a></p><p><a href="https://en.hackndo.com/ntlm-relay/" target="_blank" rel="noopener noreferrer">ntlm_relay_by_hackndo</a></p>`,42)]))}const h=i(s,[["render",r],["__file","NTLM签名.html.vue"]]),g=JSON.parse('{"path":"/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/NTLM%E4%B8%93%E9%A2%98/NTLM%E7%AD%BE%E5%90%8D.html","title":"NTLM签名","lang":"zh-CN","frontmatter":{"description":"NTLM签名 这一篇主要是讲讲为了防止ntlm relay而做的一些防护措施即签名问题。 签名方式 简单来说客户端会和服务端商量使用哪一串字符进行加密，如果我们得不到这串字符，就只能进行流量的转发，而无法进行relay 签名的整个过程中有3个key exported_session_key 如下该key的加密规则 这个key是随机数。如果开启签名的话，...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/NTLM%E4%B8%93%E9%A2%98/NTLM%E7%AD%BE%E5%90%8D.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"NTLM签名"}],["meta",{"property":"og:description","content":"NTLM签名 这一篇主要是讲讲为了防止ntlm relay而做的一些防护措施即签名问题。 签名方式 简单来说客户端会和服务端商量使用哪一串字符进行加密，如果我们得不到这串字符，就只能进行流量的转发，而无法进行relay 签名的整个过程中有3个key exported_session_key 如下该key的加密规则 这个key是随机数。如果开启签名的话，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/t01f6642281b8157af5.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"NTLM签名\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/t01f6642281b8157af5.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/jiami.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/smb.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ldap.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/smb2.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/askkk1.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/enables.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/origin.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/respoinse.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"签名方式","slug":"签名方式","link":"#签名方式","children":[]},{"level":2,"title":"SMB签名","slug":"smb签名","link":"#smb签名","children":[]},{"level":2,"title":"LDAP签名","slug":"ldap签名","link":"#ldap签名","children":[]},{"level":2,"title":"SMB签名流量分析","slug":"smb签名流量分析","link":"#smb签名流量分析","children":[{"level":3,"title":"参考链接：","slug":"参考链接","link":"#参考链接","children":[]}]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":3,"words":901},"filePathRelative":"渗透测试/NTLM专题/NTLM签名.md","localizedDate":"2025年1月16日","excerpt":"\\n<p>这一篇主要是讲讲为了防止ntlm relay而做的一些防护措施即签名问题。</p>\\n<h2>签名方式</h2>\\n<p>简单来说客户端会和服务端商量使用哪一串字符进行加密，如果我们得不到这串字符，就只能进行流量的转发，而无法进行relay</p>\\n<p>签名的整个过程中有3个key</p>\\n<h4>exported_session_key</h4>\\n<p>如下该key的加密规则</p>\\n<div class=\\"language-python line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"python\\" data-title=\\"python\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">def</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> get_random_export_session_key</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">():</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    return</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> os.</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#61AFEF\\">urandom</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">16</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">)</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{h as comp,g as data};
