import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as r}from"./app-DS0ZCcmM.js";const l={};function n(s,e){return r(),a("div",null,e[0]||(e[0]=[t('<h1 id="jdbc-connection" tabindex="-1"><a class="header-anchor" href="#jdbc-connection"><span>JDBC_Connection</span></a></h1><ul><li><p>为什么第一步是Class.forName(CLASS_NAME);//注册JDBC驱动类</p><p>Class.forName会调用静态代码块以及构造方法，而在com.mysql.jdbc.Driver下，静态代码块中注册了驱动包</p><p>如果反射某个类又不想初始化类方法有两种途径：</p><ol><li>使用<code>Class.forName(&quot;xxxx&quot;, false, loader)</code>方法，将第二个参数传入false。</li><li>ClassLoader.load(&quot;xxxx&quot;);</li></ol></li><li><p>为什么可以省去Class.forName</p><p>Java的SPI特性，DriverManager<code>在初始化的时候会调用</code>java.util.ServiceLoader<code>类提供的SPI机制，Java会自动扫描jar包中的</code>META-INF/services<code>目录下的文件，并且还会自动的</code>Class.forName(文件中定义的类)</p></li></ul>',2)]))}const m=o(l,[["render",n],["__file","JDBC.html.vue"]]),p=JSON.parse('{"path":"/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80/JDBC.html","title":"JDBC_Connection","lang":"zh-CN","frontmatter":{"description":"JDBC_Connection 为什么第一步是Class.forName(CLASS_NAME);//注册JDBC驱动类 Class.forName会调用静态代码块以及构造方法，而在com.mysql.jdbc.Driver下，静态代码块中注册了驱动包 如果反射某个类又不想初始化类方法有两种途径： 使用Class.forName(\\"xxxx\\", fal...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80/JDBC.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"JDBC_Connection"}],["meta",{"property":"og:description","content":"JDBC_Connection 为什么第一步是Class.forName(CLASS_NAME);//注册JDBC驱动类 Class.forName会调用静态代码块以及构造方法，而在com.mysql.jdbc.Driver下，静态代码块中注册了驱动包 如果反射某个类又不想初始化类方法有两种途径： 使用Class.forName(\\"xxxx\\", fal..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JDBC_Connection\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":0.52,"words":155},"filePathRelative":"Java学习/Java基础/JDBC.md","localizedDate":"2025年1月16日","excerpt":"\\n<ul>\\n<li>\\n<p>为什么第一步是Class.forName(CLASS_NAME);//注册JDBC驱动类</p>\\n<p>Class.forName会调用静态代码块以及构造方法，而在com.mysql.jdbc.Driver下，静态代码块中注册了驱动包</p>\\n<p>如果反射某个类又不想初始化类方法有两种途径：</p>\\n<ol>\\n<li>使用<code>Class.forName(\\"xxxx\\", false, loader)</code>方法，将第二个参数传入false。</li>\\n<li>ClassLoader.load(\\"xxxx\\");</li>\\n</ol>\\n</li>\\n<li>\\n<p>为什么可以省去Class.forName</p>\\n<p>Java的SPI特性，DriverManager<code>在初始化的时候会调用</code>java.util.ServiceLoader<code>类提供的SPI机制，Java会自动扫描jar包中的</code>META-INF/services<code>目录下的文件，并且还会自动的</code>Class.forName(文件中定义的类)</p>\\n</li>\\n</ul>","autoDesc":true}');export{m as comp,p as data};
