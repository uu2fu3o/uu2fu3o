import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as c,o as r}from"./app-DS0ZCcmM.js";const p={};function i(n,e){return r(),t("div",null,e[0]||(e[0]=[c('<h1 id="docker的底层实现" tabindex="-1"><a class="header-anchor" href="#docker的底层实现"><span>Docker的底层实现</span></a></h1><h2 id="基本架构" tabindex="-1"><a class="header-anchor" href="#基本架构"><span>基本架构</span></a></h2><p>Docker采用C/S架构。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p><p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p><h2 id="命名空间" tabindex="-1"><a class="header-anchor" href="#命名空间"><span>命名空间</span></a></h2><p>Linux 命名空间（namespace）是 Linux 内核的一种功能，该功能能够将内核资源分割，使得一组进程能够看到一套资源，而另一组进程看到另一套资源。</p><p>Linux 命名空间主要用于隔离系统资源，每个命名空间内的进程只能看到当前命名空间内的资源，而看不到其他命名空间的资源。这样可以增强系统的安全性，防止进程间的相互干扰。</p><p>Linux 的命名空间主要包括以下几种类型：</p><ul><li>PID 命名空间：用于隔离进程 ID #例如不同用户的进程就通过pid进行隔离</li><li>NET 命名空间：用于隔离网络接口、网络栈、防火墙规则等网络资源</li><li>MNT 命名空间：用于隔离挂载点（文件系统）</li><li>UTS 命名空间：用于隔离主机名和 NIS 域名</li><li>IPC 命名空间：用于隔离 System V IPC 对象和 POSIX 消息队列</li><li>USER 命名空间：用于隔离用户 ID 和组 ID</li></ul><p>Docker 使用 Linux 命名空间来实现容器的隔离。每个容器都有自己的进程、网络、IPC、MNT、USER 和 UTS 命名空间。</p><p>以pid命名空间为例：</p><p>当 Docker 创建一个新的容器时，它会创建一个新的 PID 命名空间。Docker 会把容器内运行的第一个进程当作 PID 为 1 的进程，通常就是你在 Dockerfile 中指定的 CMD 或 ENTRYPOINT 命令启动的进程。这将成为容器中所有其他进程的父进程。</p><blockquote><p>我将pid命名空间理解成一个特殊的进程，这种说法是并不恰当的</p><p>正确的说法，应该是创建一个pid命名空间(这是linux的一种特殊功能)，在其中启动一个pid为1的进程(这是docker启动的第一个进程),使得这个进程看起来好像是一个全新系统的第一个进程，此后容器内所有的进程都会成为其子进程</p></blockquote><p>其他的命名空间的理解都大致相同，对于用户名空间,通过创建新的用户命名空间，Docker 可以将容器内的 root 用户映射到主机上的一个非特权用户。包括MNT命名空间都是比较重要的，对于之后的安全问题很有帮助。</p><blockquote><p>每种命名空间在创建时都会被赋予一个独一无二的 inode 数，你可以使用<code>docker inspect &lt;container_id&gt;</code>命令查看这些 inode 数。</p></blockquote><h2 id="控制组" tabindex="-1"><a class="header-anchor" href="#控制组"><span>控制组</span></a></h2><p>控制组（cgroups）是Linux 内核的一个特性，主要用于对共享资源进行隔离、限制、审计等。在Docker中，控制组具有关键的作用，主要用来分配和控制Docker容器的资源。</p><p>控制组提供以下功能：</p><ol><li>资源限制（Resource limiting）：例如memory子系统可以为进程组设定一个memory使用的上限。</li><li>公平资源共享：确保各个容器可以公平地分享主机的内存、CPU、磁盘IO等资源。</li><li>资源隔离：例如CPU隔离，cgroups是Linux内核的一个功能，用于限制、统计和隔离一个进程组的系统资源。</li></ol><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下</p><p>这些目录被称为子系统，通过文件来限制资源</p><h2 id="联合文件系统" tabindex="-1"><a class="header-anchor" href="#联合文件系统"><span>联合文件系统</span></a></h2><p>联合文件系统（UnionFS）是Docker镜像和容器的技术基础，它支持对文件系统的修改作为一次提交叠加到原有的文件层，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><p>我们之前简单介绍过，docker镜像是分层存储的，每一层都相当于一个目录，当我们构建完成时，所有的层级会被挂载到同一个虚拟文件系统下，我们能够在这个系统下查看到所有层级的文件。这点的实现就是通过联合文件系统。</p><p>再例如，镜像B是在镜像A的基础上进行创建的，因此A的层会被复用，共享只读层，节省了存储空间。</p><blockquote><p>简单来说就是将几个目录挂到同一个地方，方便我们管理。</p></blockquote><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h2><p>docker运用了linux上的两个概念来实现网络--网络命名空间和虚拟网络设备(veth pair)</p><p>网络命名空间使得docker容器拥有自己的ip地址等规则</p><p>docker分别在宿主机和容器中创建一个虚拟接口用于通信(这杨一对接口称作veth pair)</p><p>当docker创建一个新容器时，会创建一个新的网络命名空间，在这个网络命名空间中为容器建立一个新的接口(通常是eth0),同时在宿主机的网络命名空间创建一个veth设备，通常为veth+随机数/字符的格式。Docker 进程会将宿主机端的veth设备接入到一个特殊的网络接口，叫做docker0网桥。docker0网桥就像一个交换机，负责转发来自容器的数据包。</p><blockquote><p>这里其实涉及了两个命名空间，一个是容器内的网络命名空间，另一个是宿主机的</p></blockquote>',32)]))}const d=o(p,[["render",i],["__file","Docker的底层实现.html.vue"]]),s=JSON.parse('{"path":"/%E4%BA%91/Docker/Docker%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html","title":"Docker的底层实现","lang":"zh-CN","frontmatter":{"description":"Docker的底层实现 基本架构 Docker采用C/S架构。Docker 守护进程 （Daemon）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。 客户端和服务端既可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。 命名空间 Linux 命名空间（namespace）是 Linux 内核...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E4%BA%91/Docker/Docker%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"Docker的底层实现"}],["meta",{"property":"og:description","content":"Docker的底层实现 基本架构 Docker采用C/S架构。Docker 守护进程 （Daemon）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。 客户端和服务端既可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。 命名空间 Linux 命名空间（namespace）是 Linux 内核..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker的底层实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"基本架构","slug":"基本架构","link":"#基本架构","children":[]},{"level":2,"title":"命名空间","slug":"命名空间","link":"#命名空间","children":[]},{"level":2,"title":"控制组","slug":"控制组","link":"#控制组","children":[]},{"level":2,"title":"联合文件系统","slug":"联合文件系统","link":"#联合文件系统","children":[]},{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":4.83,"words":1449},"filePathRelative":"云/Docker/Docker的底层实现.md","localizedDate":"2025年1月16日","excerpt":"\\n<h2>基本架构</h2>\\n<p>Docker采用C/S架构。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>\\n<p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>\\n<h2>命名空间</h2>\\n<p>Linux 命名空间（namespace）是 Linux 内核的一种功能，该功能能够将内核资源分割，使得一组进程能够看到一套资源，而另一组进程看到另一套资源。</p>\\n<p>Linux 命名空间主要用于隔离系统资源，每个命名空间内的进程只能看到当前命名空间内的资源，而看不到其他命名空间的资源。这样可以增强系统的安全性，防止进程间的相互干扰。</p>","autoDesc":true}');export{d as comp,s as data};
