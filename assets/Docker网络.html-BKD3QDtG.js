import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as n}from"./app-DS0ZCcmM.js";const l={};function t(d,i){return n(),e("div",null,i[0]||(i[0]=[a(`<h1 id="docker网络" tabindex="-1"><a class="header-anchor" href="#docker网络"><span>Docker网络</span></a></h1><blockquote><p>主要是端口映射和网络配置方面的东西</p></blockquote><h2 id="使用网络" tabindex="-1"><a class="header-anchor" href="#使用网络"><span>使用网络</span></a></h2><h3 id="外部访问容器" tabindex="-1"><a class="header-anchor" href="#外部访问容器"><span>外部访问容器</span></a></h3><div class="language-dockerfile line-numbers-mode" data-highlighter="shiki" data-ext="dockerfile" data-title="dockerfile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-P #Docker会随机映射一个端口到内部容器开放的网络端口</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">docker logs container_name #查看访问记录</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-p #可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>映射所有接口地址</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>hostPort:containerPort</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认绑定本地所有接口上的所有地址</p></li><li><p>映射指定接口地址</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ip:hostPort:containerPort</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>映射到指定地址的任意端口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ip::containerPort</span></span>
<span class="line"><span>eg:docker run -d -p 127.0.0.1::80 nginx:latest</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><blockquote><p>查看端口</p><p>docker port cd0862f6acfe</p><p>80/tcp -&gt; 0.0.0.0:32768<br> 80/tcp -&gt; :::32768</p></blockquote><p>注意：容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。） -p可以一次绑定多个端口</p><blockquote><p>例如，我不加-p等参数启动一个nginx,通过docker port id查看是没有端口映射的，但是docker ps会看到80/tcp，这说明容器开启了80端口，但是没有映射到本机</p></blockquote><h3 id="通过网络使容器互联" tabindex="-1"><a class="header-anchor" href="#通过网络使容器互联"><span>通过网络使容器互联</span></a></h3><ul><li><p>新建网络</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker network create -d bridge new-net</span></span>
<span class="line"><span>#-d指定Docker的网络类型，其中overlay 网络类型用于 Swarm mode</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>连接容器</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run -it --rm --name netry1 --network new-net busybox sh</span></span>
<span class="line"><span>docker run -it --rm --name netry2 --network new-net busybox sh</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>现在两个容器处于互联状态，能够相互ping通</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240113204505934.png" alt="image-20240113204505934" tabindex="0" loading="lazy"><figcaption>image-20240113204505934</figcaption></figure><blockquote><p>可能在过程中你会产生向我一样的疑惑，为什么查找不到对应的DNS解析，却能够直接ping容器名</p><p>自定义网络的DNS是内置服务器，由Docker daemon进行管理，并不通过常规的文件存储或记录。这个DNS会自动更新。</p><p>如果你查看DNS文件，会发现</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/ # cat /etc/resolv.conf</span></span>
<span class="line"><span>search localdomain</span></span>
<span class="line"><span>nameserver 127.0.0.11</span></span>
<span class="line"><span>options ndots:0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="配置dns" tabindex="-1"><a class="header-anchor" href="#配置dns"><span>配置DNS</span></a></h3><p>在容器中执行mount,我们能看到挂载信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/dev/sda1 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro)</span></span>
<span class="line"><span>/dev/sda1 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro)</span></span>
<span class="line"><span>/dev/sda1 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><ul><li><p>配置全部容器的DNS</p><p>在<code>/etc/docker/daemon.json</code> 文件中增加，格式如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;dns&quot; : [</span></span>
<span class="line"><span>    &quot;114.114.114.114&quot;,</span></span>
<span class="line"><span>    &quot;8.8.8.8&quot;</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>手动指定容器配置</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote></li></ul><h2 id="网络配置" tabindex="-1"><a class="header-anchor" href="#网络配置"><span>网络配置</span></a></h2><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>Docker 随机分配一个本地未占用的私有网段中的一个地址给 <code>docker0</code> 接口。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240113212928943.png" alt="image-20240113212928943" tabindex="0" loading="lazy"><figcaption>image-20240113212928943</figcaption></figure><p>图片来自<a href="https://yeasy.gitbook.io/docker_practice/advanced_network" target="_blank" rel="noopener noreferrer">Docker-从入门到实践</a></p><h3 id="容器访问控制" tabindex="-1"><a class="header-anchor" href="#容器访问控制"><span>容器访问控制</span></a></h3><p>主要通过linux上的iptables防火墙来进行管理和实现。</p><ul><li><p>访问外部网络</p><p>依靠于本地系统的转发支持</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>┌──(root㉿kali)-[~]</span></span>
<span class="line"><span>└─# sysctl net.ipv4.ip_forward </span></span>
<span class="line"><span>net.ipv4.ip_forward = 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果为1，则说明系统支持转发</p><p>为0需要手动开启</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sysctl -w net.ipv4.ip_forward=1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><blockquote><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1</p></blockquote><ul><li><p>容器之间相互访问</p><p>需要以下支持：</p><p>1.容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</p><p>2.本地系统的防火墙软件 -- <code>iptables</code> 是否允许通过。</p></li></ul><blockquote><p>和之前的通过网络使容器互联性质相同，只不过这里使用的是默认的docker0网桥</p><p>是否允许通过是指是否允许docker容器之间的互相通信，关于这个可以通过iptables -L来查看</p></blockquote><ul><li><p>容器之间的访问端口</p><p>所有端口：</p><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p><p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{&quot;icc&quot;: false}</code> 来禁止它。</p><p>当仅需要访问指定端口：</p><p>指定-icc=false关闭网络访问，通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口</p><blockquote><p>在docker1.9之后就不再推荐使用--link,容器之间的访问最好还是通过新建网络的形式</p></blockquote></li></ul><h3 id="端口映射" tabindex="-1"><a class="header-anchor" href="#端口映射"><span>端口映射</span></a></h3><ul><li><p>容器访问外部</p><p>之前提到过，容器访问外部依赖于系统的转发，查看iptables的nat规则</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Chain POSTROUTING (policy ACCEPT)</span></span>
<span class="line"><span>target     prot opt source               destination         </span></span>
<span class="line"><span>MASQUERADE  0    --  172.18.0.0/16        0.0.0.0/0           </span></span>
<span class="line"><span>MASQUERADE  0    --  172.17.0.0/16        0.0.0.0/0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条规则使用<code>MASQUERADE</code>目标，在所有来自<code>172.17.0.0/16</code>网络并且目的地不在<code>172.17.0.0/16</code>网络内的流量上执行源地址转换（SNAT）</p><p>这使得docker容器的ip地址看起来像主机的IP地址，也就是伪装。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p></li><li><p>外部访问容器实现</p><p>外部访问容器依赖于在docker run时映射的端口,查看iptables中的nat规则，会添加如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>DNAT       6    --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>0.0.0.0，意味着将接受主机来自所有接口的流量,可以自定义更严格的规则</p><p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;ip&quot;: &quot;0.0.0.0&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li></ul><h3 id="网桥配置" tabindex="-1"><a class="header-anchor" href="#网桥配置"><span>网桥配置</span></a></h3><p>我们知道docker服务默认存在一个网桥dokcer0,它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络.</p><p>我们可以在启动docker服务时自定义这个网桥</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>--bip=CIDR IP 地址加掩码格式，例如 192.168.1.5/24</span></span>
<span class="line"><span>--mtu=BYTES 覆盖默认的 Docker mtu 配置 // MTU（接口允许接收的最大传输单元），通常是 1500 Bytes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用 <code>brctl show</code> 来查看网桥和端口连接信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker0         8000.0242cb1a498f       no              veth8871dc2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>每次创建新的容器，会从可用地址当中选取一个分配给容器的eth0端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p><ul><li><p>自定义网桥</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">brctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> addbr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #创建一个网桥</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> addr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 192.168.5.1/24</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> dev</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #添加地址块</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> link</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> dev</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> up</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #启动该网桥</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> addr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> show</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge0</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #确认</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">36:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">BROADCAST,MULTICAST,UP,LOWER_U</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">P&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">mtu</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1500</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> qdisc</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> noqueue</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> state</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> UNKNOWN</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> group</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> default</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> qlen</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    link/ether</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 86:84:b8:5d:dd:ba</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> brd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ff:ff:ff:ff:ff:ff</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inet</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 192.168.5.1/24</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> scope</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> global</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       valid_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> preferred_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inet6</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fe80::8484:b8ff:fe5d:ddba/64</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> scope</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> link</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> proto</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kernel_ll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       valid_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> preferred_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">如果你需要删除网桥，首先需要停止该网桥上的服务以及网桥</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> link</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> dev</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> down</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">brctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delbr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如果你希望docker一直使用同一个网桥，可以在配置文件<code>/etc/docker/daemon.json</code> 中添加如下内容</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;bridge&quot;: &quot;bridge0&quot;,</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li></ul><p>注意：在docker内部修改网络配置文件，在容器终止或重启后并不会保存下来</p><h3 id="配置网络代理" tabindex="-1"><a class="header-anchor" href="#配置网络代理"><span>配置网络代理</span></a></h3><p>目的时为了加速镜像拉取构建和使用，一般不怎么用到这个:)</p><ul><li><p>为dockerd创建配置文件夹</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mkdir -p /etc/systemd/system/docker.service.d</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>为 dockerd 创建 HTTP/HTTPS 网络代理的配置文件，文件路径是 /etc/systemd/system/docker.service.d/http-proxy.conf 。并在该文件中添加相关环境变量。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[Service]</span></span>
<span class="line"><span>Environment=&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;</span></span>
<span class="line"><span>Environment=&quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot;</span></span>
<span class="line"><span>Environment=&quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><blockquote><p>需要重启docker服务</p></blockquote><ul><li><p>为容器设置网络代理</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>更改 docker 客户端配置：创建或更改 ~/.docker/config.json，并在该文件中添加相关配置</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span> &quot;proxies&quot;:</span></span>
<span class="line"><span> {</span></span>
<span class="line"><span>   &quot;default&quot;:</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>     &quot;httpProxy&quot;: &quot;http://proxy.example.com:8080/&quot;,</span></span>
<span class="line"><span>     &quot;httpsProxy&quot;: &quot;http://proxy.example.com:8080/&quot;,</span></span>
<span class="line"><span>     &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.example.com&quot;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者在docker run时指定环境变量</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>--env:</span></span>
<span class="line"><span>HTTP_PROXY=&quot;http://proxy.example.com:8080/&quot;</span></span>
<span class="line"><span>HTTPS_PROXY=&quot;http://proxy.example.com:8080/&quot;</span></span>
<span class="line"><span>NO_PROXY=&quot;localhost,127.0.0.1,.example.com&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>为docker build过程设置代理</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>--build-arg指定相关环境变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>docker build \\</span></span>
<span class="line"><span>    --build-arg &quot;HTTP_PROXY=http://proxy.example.com:8080/&quot; \\</span></span>
<span class="line"><span>    --build-arg &quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot; \\</span></span>
<span class="line"><span>    --build-arg &quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; .</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>在dockerfile中指定代理</span></span>
<span class="line"><span>ENV HTTP_PROXY=&quot;http://proxy.example.com:8080/&quot;</span></span>
<span class="line"><span>#其余参数同环境变量</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><blockquote><p>关于docker的点到点链接，网上有很多例子，最推荐的方法还是通过自定义网络进行连接，需要注意的是自定义网络的方法不同于默认的网桥，默认的网桥虽然实现了容器之间的通信，这种点到点的通信仅限于容器之间，不通过网桥而直接通信，对于容器与容器直接更加效率。</p></blockquote>`,49)]))}const c=s(l,[["render",t],["__file","Docker网络.html.vue"]]),h=JSON.parse('{"path":"/%E4%BA%91/Docker/Docker%E7%BD%91%E7%BB%9C.html","title":"Docker网络","lang":"zh-CN","frontmatter":{"description":"Docker网络 主要是端口映射和网络配置方面的东西 使用网络 外部访问容器 映射所有接口地址 默认绑定本地所有接口上的所有地址 映射指定接口地址 映射到指定地址的任意端口 查看端口 docker port cd0862f6acfe 80/tcp -> 0.0.0.0:32768 80/tcp -> :::32768 注意：容器有自己的内部网络和 ip...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E4%BA%91/Docker/Docker%E7%BD%91%E7%BB%9C.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"Docker网络"}],["meta",{"property":"og:description","content":"Docker网络 主要是端口映射和网络配置方面的东西 使用网络 外部访问容器 映射所有接口地址 默认绑定本地所有接口上的所有地址 映射指定接口地址 映射到指定地址的任意端口 查看端口 docker port cd0862f6acfe 80/tcp -> 0.0.0.0:32768 80/tcp -> :::32768 注意：容器有自己的内部网络和 ip..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240113204505934.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker网络\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240113204505934.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/2024/image-20240113212928943.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"使用网络","slug":"使用网络","link":"#使用网络","children":[{"level":3,"title":"外部访问容器","slug":"外部访问容器","link":"#外部访问容器","children":[]},{"level":3,"title":"通过网络使容器互联","slug":"通过网络使容器互联","link":"#通过网络使容器互联","children":[]},{"level":3,"title":"配置DNS","slug":"配置dns","link":"#配置dns","children":[]}]},{"level":2,"title":"网络配置","slug":"网络配置","link":"#网络配置","children":[{"level":3,"title":"容器访问控制","slug":"容器访问控制","link":"#容器访问控制","children":[]},{"level":3,"title":"端口映射","slug":"端口映射","link":"#端口映射","children":[]},{"level":3,"title":"网桥配置","slug":"网桥配置","link":"#网桥配置","children":[]},{"level":3,"title":"配置网络代理","slug":"配置网络代理","link":"#配置网络代理","children":[]}]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":8.11,"words":2433},"filePathRelative":"云/Docker/Docker网络.md","localizedDate":"2025年1月16日","excerpt":"\\n<blockquote>\\n<p>主要是端口映射和网络配置方面的东西</p>\\n</blockquote>\\n<h2>使用网络</h2>\\n<h3>外部访问容器</h3>\\n<div class=\\"language-dockerfile line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"dockerfile\\" data-title=\\"dockerfile\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">-P #Docker会随机映射一个端口到内部容器开放的网络端口</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">docker logs container_name #查看访问记录</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">-p #可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器.</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">#ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,h as data};
