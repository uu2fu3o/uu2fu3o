import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as n}from"./app-DS0ZCcmM.js";const r={};function p(o,e){return n(),a("div",null,e[0]||(e[0]=[t(`<h1 id="特权与危险acl" tabindex="-1"><a class="header-anchor" href="#特权与危险acl"><span>特权与危险ACL</span></a></h1><h2 id="特权" tabindex="-1"><a class="header-anchor" href="#特权"><span>特权</span></a></h2><p>A在访问B时，首先判断B是不是需要特权才能访问，如果是则需要检查A的Access token看有没有那个特权</p><p>如果我们需要赋予域用户特权一般都是通过组策略下发。比如说默认情况底下的<code>Default Domain Controllers Policy(GUID={6AC1786C-016F-11D2-945F-00C04FB984F9})</code>这条组策略会把SeEnableDelegationPrivilege这个特权赋予<code>Administrators</code></p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104131777.png" alt="image-20231127104131777" tabindex="0" loading="lazy"><figcaption>image-20231127104131777</figcaption></figure><p>执行whoami /priv来查看当前用户的特权</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104543468.png" alt="image-20231127104543468" tabindex="0" loading="lazy"><figcaption>image-20231127104543468</figcaption></figure><h3 id="seenabledelegationprivilege" tabindex="-1"><a class="header-anchor" href="#seenabledelegationprivilege"><span>SeEnableDelegationPrivilege</span></a></h3><p>此策略设置确定哪些用户可以在用户或计算机对象上设置“受信任的委派”设置。</p><p>这个权限有关委派，默认情况底下，在域内只有<code>SeEnableDelegationPrivilege</code>权限的用户才能设置委派。而这个权限默认域内的<code>Administrators</code>组的用户才能拥有，所以我们一般都是使用SeEnableDelegationPrivilege这个权限来留后门。</p><ul><li><p>给域用户添加该特权，这一步需要域管权限</p><p>通过组策略来实现</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127122932151.png" alt="image-20231127122932151" tabindex="0" loading="lazy"><figcaption>image-20231127122932151</figcaption></figure><p>或者手动添加用户sid<code>C:\\Windows\\SYSVOL\\sysvol\\hack.com\\Policies\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit</code>的GptTmpl.inf里面,需要手动更新组策略设置</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>gpupdate /force</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此后hacker用户就可以进行设置委派操作了</p><p>接下来使用hacker用户进行委派设置建立后门</p></li><li><p>hacker用户需要拥有SeEnableDelegationPrivilege特权，并且对自己有GenericAll / GenericWrite权限(这个默认是没有的)</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127133949398.png" alt="image-20231127133949398" tabindex="0" loading="lazy"><figcaption>image-20231127133949398</figcaption></figure><p>在这里！</p></li><li><p>hacker用户需要有spn,在这之前已经设置好了，有spn的用户才可以进行委派操作</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127134346892.png" alt="image-20231127134346892" tabindex="0" loading="lazy"><figcaption>image-20231127134346892</figcaption></figure></li><li><p>hacker的useraccountControl需要有TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION</p></li><li><p>修改hacker的msDS-AllowedToDelegateTo属性，设置他的委派</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127140722249.png" alt="image-20231127140722249" tabindex="0" loading="lazy"><figcaption>image-20231127140722249</figcaption></figure><p>这样就可以直接申请票据模拟administrator访问域控了</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127144705421.png" alt="image-20231127144705421" tabindex="0" loading="lazy"><figcaption>image-20231127144705421</figcaption></figure><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127144717513.png" alt="image-20231127144717513" tabindex="0" loading="lazy"><figcaption>image-20231127144717513</figcaption></figure></li></ul><p>除此之外还有其他很多特权</p><p><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment" target="_blank" rel="noopener noreferrer">官方权限文档</a></p><h2 id="acl" tabindex="-1"><a class="header-anchor" href="#acl"><span>ACL</span></a></h2><h3 id="一些有攻击价值的acl介绍" tabindex="-1"><a class="header-anchor" href="#一些有攻击价值的acl介绍"><span>一些有攻击价值的ACL介绍</span></a></h3><p>（1） 对某些属性的WriteProperty ，有以下属性</p><ul><li>member(bf9679c0-0de6-11d0-a285-00aa003049e2)</li><li>servicePrincipalName(28630EBB-41D5-11D1-A9C1-0000F80367C1)</li><li>GPC-File-Sys-Path(f30e3bc1-9ff0-11d1-b603-0000f80367c1)</li></ul><p>（2） 扩展权限有</p><ul><li><p>User-Force-Change-Password(0299570-246d-11d0-a768-00aa006e0529)</p><p>可以在不知道当前目标用户的密码的情况下更改目标用户的密码</p></li><li><p>DS-Replication-Get-Changes(1131f6aa-9c07-11d1-f79f-00c04fc2dcd2) 和 DS-Replication-Get-Changes-All(1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</p><p>对域对象具有这两个扩展权限的用户具备dcsync 权限</p></li></ul><p>（3） 通用权限有</p><ul><li>WriteDacl</li><li>AllExtendedRights</li><li>WriteOwner</li><li>GenericWrite</li><li>GenericAll</li><li>Full Control</li></ul><p>下面逐个演示利用方式</p><ul><li><p>AddMembers</p><p>将任意用户，组或计算机添加到目标组</p><p>如果一个用户对一个组有<strong>AddMembers</strong>权限，那么这个用户可以将任何用户加入这个组，从而具备这个组的权限。</p><p>hacker用户具备对Domain Admin这个组的<strong>AddMembers</strong>权限，也就是对member(bf9679c0-0de6-11d0-a285-00aa003049e2) 这个属性的写权限。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127151749264.png" alt="image-20231127151749264" tabindex="0" loading="lazy"><figcaption>image-20231127151749264</figcaption></figure><p>这里为了方便就设置为所有权限了，通过admod将任意用户加进Domain Admin.(这里是hacker)</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152457275.png" alt="image-20231127152457275" tabindex="0" loading="lazy"><figcaption>image-20231127152457275</figcaption></figure><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152538231.png" alt="image-20231127152538231" tabindex="0" loading="lazy"><figcaption>image-20231127152538231</figcaption></figure><p>之后可以使用hacker用户直接psexec</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152737271.png" alt="image-20231127152737271" tabindex="0" loading="lazy"><figcaption>image-20231127152737271</figcaption></figure></li><li><p>servicePrincipalName(28630EBB-41D5-11D1-A9C1-0000F80367C1)</p><p>写入spn权限，如果对一个对象有写入spn权限，就可以对该对象进行kerberosting</p></li><li><p>GPC-File-Sys-Path(f30e3bc1-9ff0-11d1-b603-0000f80367c1)</p></li></ul><p>将GPO域GPT链接起来，GPT是组策略具体的策略配置信息，其位于域控制器的SYSVOL共享目录下。如果我们能够控制GPC-File-Sys-Path的话，可以将ad活动目录里面的gpo指向我们自定义的GPT，而GPT里面包含的是组策略具体的策略配置信息，也就是说我们可以修改组策略配置信息的内容。</p><p>通常用来留后门</p><ul><li><p>User-Force-Change-Password(0299570-246d-11d0-a768-00aa006e0529)</p><p>在不知道当前目标用户的密码的情况下更改目标用户的密码。强制密码更改</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127171102242.png" alt="image-20231127171102242" tabindex="0" loading="lazy"><figcaption>image-20231127171102242</figcaption></figure><p>通过admod进行强制密码更改</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>admod -b CN=Administrator,CN=Users,DC=hack,DC=com unicodepwd::123!@#qazwsx -optenc</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>通过修改后的密码去psexec</p></li><li><p>Dcsync</p><p>最常用的，只需要具备以下两个权限就可以进行dcsync</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&#39;DS-Replication-Get-Changes&#39;     = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2</span></span>
<span class="line"><span>&#39;DS-Replication-Get-Changes-All&#39; = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127172559906.png" alt="image-20231127172559906" tabindex="0" loading="lazy"><figcaption>image-20231127172559906</figcaption></figure><p>常见的有mimikatz的dcsync以及screatdump支持远程提供用户账户来dump,这里不做演示</p></li><li><p>WriteDACL</p><p>将新ACE写入目标对象的DACL的功能。例如，攻击者可以向目标对象DACL写入新的ACE，从而使攻击者可以“完全控制”目标对象。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127204026372.png" alt="image-20231127204026372" tabindex="0" loading="lazy"><figcaption>image-20231127204026372</figcaption></figure><p>这一条可以通过admod往上添加，或者使用图形化界面,在实际测试时使用admod没有成功，初步认为是分号的问题</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>admod -b dc=hack,dc=com &quot;nTSecurityDescriptor:+:(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;S-1-5-21-754643614-3937478331-2139222398-1116)&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果成功添加该ACE，则对应用户拥有dcsync权限</p></li><li><p>AllExtendedRights</p><p>所有扩展权限。比如，User-Force-Change-Password权限。</p></li><li><p>WriteOwner</p></li></ul><p>这个权限这个修改Owner为自己。</p><p>而Owner 默认拥有WriteDacl 和 RIGHT_READ_CONTROL权限。因此我们就可以利用WriteDacl的利用方式。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127211528905.png" alt="image-20231127211528905" tabindex="0" loading="lazy"><figcaption>image-20231127211528905</figcaption></figure><p>如果我们是域管用户，把所有者改为hacker,hacker就具备了writeDacl权限，例如给hacker用户添加修改密码的权限</p><ul><li>GenericWrite</li></ul><p>可以修改所有参数，因此包括对某些属性的WriteProperty，比如member。</p><ul><li>GenericAll</li></ul><p>这包括riteDacl和WriteOwner，WRITE_PROPERTY等权限。随便找一个利用就行了。</p><ul><li>Full Control</li></ul><p>这个权限就具备以上所有的权限，随便挑一个特殊权限的攻击方式进行攻击就行了。</p><h2 id="adminsdholder" tabindex="-1"><a class="header-anchor" href="#adminsdholder"><span>AdminSDHolder</span></a></h2><p>AdminSDHolder是位于Active Directory中的系统分区CN=AdminSDHolder,CN=System,DC=hack,DC=com的一个对象</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127212952520.png" alt="image-20231127212952520" tabindex="0" loading="lazy"><figcaption>image-20231127212952520</figcaption></figure><p>他会作为域内某些特权组的安全模版。所谓安全模版，就是说有一个进程(SDProp),每隔60分钟运行一次，将这个对象的ACL复制到某些特权组成员的对象的ACL里面去。 这些特权组和用户默认有 · Account Operators · Administrator · Administrators · Backup Operators · Domain Admins · Domain Controllers · Enterprise Admins · Krbtgt · Print Operators · Read-only Domain Controllers · Replicator · Schema Admins · Server Operators</p><p>属性adminCount在Active Directory中标记特权组和用户，对于特权组和用户，该属性将设置为1。通过查看adminCount设置为1的所有对象，可以找到所有的特权组和用户。 但值得注意的是。一旦用户从特权组中删除，他们仍将adminCount值保持为1，但Active Directory不再将其视为受保护的对象。因此通过admincount=1匹配到的所有对象，不一定都是特权组</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127213852259.png" alt="image-20231127213852259" tabindex="0" loading="lazy"><figcaption>image-20231127213852259</figcaption></figure><p>对于这个作用我们可以有比较直接的利用，添加一条ACE，使hacker用户对该对象有完全控制权。</p><p>由于这个ACL过个60分钟会同步到特权组和用户，这个特权组和用户包括域管，所以hacker对域管已经有完全控制的权限了，达到了后门的目的。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127214340533.png" alt="image-20231127214340533" tabindex="0" loading="lazy"><figcaption>image-20231127214340533</figcaption></figure><p>默认时间可以在注册表当中修改</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HKLM\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters\\AdminSDProtectFrequency</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认60分钟且该项目不存在，修改需要新增</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接：</span></a></h2><p><a href="https://daiker.gitbook.io/windows-protocol/ldap-pian/12" target="_blank" rel="noopener noreferrer">windows protocol</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/adschema/extended-rights" target="_blank" rel="noopener noreferrer">microsoft权限&amp;属性</a></p>`,51)]))}const g=i(r,[["render",p],["__file","特权与危险ACL.html.vue"]]),s=JSON.parse('{"path":"/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/LDAP%E4%B8%93%E9%A2%98/%E7%89%B9%E6%9D%83%E4%B8%8E%E5%8D%B1%E9%99%A9ACL.html","title":"特权与危险ACL","lang":"zh-CN","frontmatter":{"description":"特权与危险ACL 特权 A在访问B时，首先判断B是不是需要特权才能访问，如果是则需要检查A的Access token看有没有那个特权 如果我们需要赋予域用户特权一般都是通过组策略下发。比如说默认情况底下的Default Domain Controllers Policy(GUID={6AC1786C-016F-11D2-945F-00C04FB984F...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/LDAP%E4%B8%93%E9%A2%98/%E7%89%B9%E6%9D%83%E4%B8%8E%E5%8D%B1%E9%99%A9ACL.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"特权与危险ACL"}],["meta",{"property":"og:description","content":"特权与危险ACL 特权 A在访问B时，首先判断B是不是需要特权才能访问，如果是则需要检查A的Access token看有没有那个特权 如果我们需要赋予域用户特权一般都是通过组策略下发。比如说默认情况底下的Default Domain Controllers Policy(GUID={6AC1786C-016F-11D2-945F-00C04FB984F..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104131777.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"特权与危险ACL\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104131777.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104543468.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127122932151.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127133949398.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127134346892.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127140722249.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127144705421.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127144717513.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127151749264.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152457275.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152538231.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127152737271.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127171102242.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127172559906.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127204026372.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127211528905.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127212952520.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127213852259.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127214340533.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"特权","slug":"特权","link":"#特权","children":[{"level":3,"title":"SeEnableDelegationPrivilege","slug":"seenabledelegationprivilege","link":"#seenabledelegationprivilege","children":[]}]},{"level":2,"title":"ACL","slug":"acl","link":"#acl","children":[{"level":3,"title":"一些有攻击价值的ACL介绍","slug":"一些有攻击价值的acl介绍","link":"#一些有攻击价值的acl介绍","children":[]}]},{"level":2,"title":"AdminSDHolder","slug":"adminsdholder","link":"#adminsdholder","children":[]},{"level":2,"title":"参考链接：","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":6.25,"words":1875},"filePathRelative":"渗透测试/LDAP专题/特权与危险ACL.md","localizedDate":"2025年1月16日","excerpt":"\\n<h2>特权</h2>\\n<p>A在访问B时，首先判断B是不是需要特权才能访问，如果是则需要检查A的Access token看有没有那个特权</p>\\n<p>如果我们需要赋予域用户特权一般都是通过组策略下发。比如说默认情况底下的<code>Default Domain Controllers Policy(GUID={6AC1786C-016F-11D2-945F-00C04FB984F9})</code>这条组策略会把SeEnableDelegationPrivilege这个特权赋予<code>Administrators</code></p>\\n<figure><img src=\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ldapp/image-20231127104131777.png\\" alt=\\"image-20231127104131777\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20231127104131777</figcaption></figure>","autoDesc":true}');export{g as comp,s as data};
