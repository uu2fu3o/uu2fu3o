import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as t}from"./app-DS0ZCcmM.js";const n={};function l(h,e){return t(),s("div",null,e[0]||(e[0]=[a(`<h1 id="相关漏洞" tabindex="-1"><a class="header-anchor" href="#相关漏洞"><span>相关漏洞</span></a></h1><p>这一篇主要是对现有的部分漏洞进行复现，以及部分相关细节的补充，之后新的漏洞也就不会补充到这篇里面了</p><h2 id="ms08-068" tabindex="-1"><a class="header-anchor" href="#ms08-068"><span>MS08-068</span></a></h2><p>当用户拿到smb请求之后，最直接的就是把请求relay回本身，即Reflect.从而控制机器本身。</p><p>微软在kb957097补丁里面通过修改SMB身份验证答复的验证方式来防止凭据重播，从而解决了该漏洞。</p><p>微软所做的措施如下，</p><p>主机A向主机B(访问\\B)进行SMB认证的时候，将<em>pszTargetName</em>设置为<code>cifs/B</code>,然后在type 2拿到主机B发送Challenge之后，在lsass里面缓存(Challenge,<code>cifs/B</code>)。</p><p>然后主机B在拿到主机A的type 3之后，会去lsass里面有没有缓存(Challenge,<code>cifs/b</code>)，如果存在缓存，那么认证失败。</p><p>这种情况底下，如果主机B和主机A是不同的主机的话，那lsass里面就不会缓存(Challenge,<code>cifs/B</code>)。如果是同一台主机的话，那lsass里面肯定有缓存，这个时候就会认证失败。</p><p>这里借用一下图片</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ms08-068.png" alt="ms08-068" tabindex="0" loading="lazy"><figcaption>ms08-068</figcaption></figure><p>该漏洞利用对win2000 至win2008有效。</p><p>漏洞exp可以参看：<a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS08-068" target="_blank" rel="noopener noreferrer">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS08-068</a></p><h2 id="cve-2015-0005" tabindex="-1"><a class="header-anchor" href="#cve-2015-0005"><span>CVE-2015-0005</span></a></h2><p>应用服务器在收到客户端的认证信息时，由于本身没有储存用户的hash，因此会将所有的消息传回域控，这个过程是通过NetLoGon协议完成的.该协议在应用服务器和域服务器之间建立一个安全会话，安全会话共享密钥基于应用服务器主机账号的口令 <code>NTLM</code> 生成。</p><h3 id="漏洞成因" tabindex="-1"><a class="header-anchor" href="#漏洞成因"><span>漏洞成因</span></a></h3><p>服务端没有用户的hash（注意：服务端并没有去向域控索要用户的hash,而是将所有数据交给域控进行判断），经过认证之后，也就无法算出key_exchange_key，这时认证服务器会像域控索要key_exchange_key.从而计算得出exported_session_key.</p><p>漏洞就出在索要key_exchange_key这一阶段，由于域控没有做鉴权，导致只要是机器用户就可以向域控索要key_exchange_key,而第三阶段的key又是能够在流量中明文抓取到的，攻击者就能经过计算得到exported_session_key.</p><p>之后的会话就能使用该key进行加解密。</p><h3 id="netlogon-步骤" tabindex="-1"><a class="header-anchor" href="#netlogon-步骤"><span>NETLOGON 步骤</span></a></h3><p>均为 RPC 远程向认证服务器调用</p><ol><li>NetrLogonSamLoginEx</li><li><code>NetrLogonSamLogonWithFlags</code></li><li>NetrLogonSamLogon</li><li>NetrLogonSamLogoff</li></ol><h3 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用"><span>漏洞利用</span></a></h3><p>该漏洞的利用在impacket的smbrelayx中已经集成，不需要额外的参数，检测到需要签名会自己调用</p><p>如果是非域主机，需要指定当前域内任意一台主机的 hash，且指定域控的 IP。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">python smbrelayx.py </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">h </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">192.168</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.30.10 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">machine</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">account hack</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">PC</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">$</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">machine</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">hashes </span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">2EAE0491D7156EE50ADC9746701F24194E00530055A08072</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">33649860ee595468</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">domain </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">192.168</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.30.10 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">c hostname</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个机器用户的凭据仅是用来向域控申请key_exchange_key作用</p><h2 id="ms16-075-hotpotato" tabindex="-1"><a class="header-anchor" href="#ms16-075-hotpotato"><span>MS16-075(HotPotato)</span></a></h2><p>较早的windows本地提权漏洞，衍生出了很多新的potato</p><p>hotptato是基于ntlm_relay来进行的，该漏洞从以下三个方面去思考</p><ul><li><p>发起ntlm请求</p><p>配合NBNS投毒欺骗和伪造WPAD代理服务器拿到用户的net-ntlm hash,所有的HTTP请求将会被重定向至“<a href="http://localhost/GETHASHESxxxxx%E2%80%9D%E2%80%9D%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84xxxxx%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%98%AF%E6%9F%90%E4%BA%9B%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%82%E5%B0%86%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%94%A8%E6%88%B7%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%AE%A1%E7%90%86%E5%91%98%E8%B4%A6%E6%88%B7%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E3%80%82" target="_blank" rel="noopener noreferrer">http://localhost/GETHASHESxxxxx””，其中的xxxxx表示的是某些唯一标识符。将会影响目标主机中所有的用户，包括管理员账户和系统账户。</a></p></li><li><p>如何进行relay</p><p>在拿到ntlm之后，虽然MS08-068限制了同台主机smb到smb的relay,但并没有限制http到smb,我们配置配合NBNS投毒欺骗和伪造WPAD代理服务器拿到的ntlm请求说http的形式，我们可以直接relay 到本机的smb。</p></li><li><p>服务端是否要求签名</p><p>我们Relay到的服务端协议是smb，除非是域内的域控，不然在工作组环节底下，或者域内的域成员机器，都是不要求签名的</p></li></ul><p>来看下漏洞细节</p><p>程序首先通过NBNS欺骗，将目标主机的WPAD指向127.0.0.1，然后检查Windows Defender更新。如果目标网络中已经有了WPAD的DNS项，可以使用 -disable_exhaust false 选项，它会导致所有DNS查询失败，从而使用NBNS查询。</p><p>获取到ntlm hash之后，进行http-&gt;smb的relay</p><p>创建一个运行用户定义命令的系统服务，以system权限运行</p><p>需要注意的是，win8/10和winserver与win7.win2008之间的部分区别，这影响了我们需要添加的参数</p><p><a href="https://github.com/foxglovesec/Potato/tree/master" target="_blank" rel="noopener noreferrer">Potato</a></p><h2 id="cve-2018-8581" tabindex="-1"><a class="header-anchor" href="#cve-2018-8581"><span>CVE-2018-8581</span></a></h2><p>能够访问任意用户的文件。</p><p>该漏洞由SSRF漏洞结合NTLM_RELAY可以访问任意用户的邮件，获取域管权限。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange.png" alt="exchange" tabindex="0" loading="lazy"><figcaption>exchange</figcaption></figure><ul><li><p>发起NTLM请求</p><p>Exchange允许任何用户为推送订阅指定所需的URL，服务器将尝试向这个URL发送通知。问题出在Exchange服务器使用<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.credentialcache.defaultcredentials" target="_blank" rel="noopener noreferrer">CredentialCache.DefaultCredentials</a>进行连接。传进的URL我们可控，也就说我们可以控制Exchange服务器向我们发起HTTP 协议的NTLM 请求。我们就能拿到Exchange机器用户的 Net-Ntlm Hash。</p><p>看下微软官方给的例子会比较容易理解</p><div class="language-c# line-numbers-mode" data-highlighter="shiki" data-ext="c#" data-title="c#" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Ensure Directory Security settings for default web site in IIS is &quot;Windows Authentication&quot;.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> url</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;http://localhost&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Create a &#39;HttpWebRequest&#39; object with the specified url.</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HttpWebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> myHttpWebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HttpWebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">WebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">url</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Assign the credentials of the logged in user or the user being impersonated.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">myHttpWebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Credentials</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> CredentialCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">DefaultCredentials</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Send the &#39;HttpWebRequest&#39; and wait for response.</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HttpWebResponse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> myHttpWebResponse</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HttpWebResponse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">myHttpWebRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetResponse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Authentication successful&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Response received successfully&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只需要知道该例子向url发送了httprequest</p></li><li><p>拿到ntlm之后要做什么</p><p>思路1：访问任意用户邮件</p><p>Exchange服务器还默认设置了以下注册表项</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\LsaDisableLoopbackCheck = 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也就是说我们可以将请求Relay 回机器本身。我们拿到的是机器用户的Net-Ntlm Hash。并不能直接用以登录。但是Exchange 机器用户可以获得TokenSerializationRight的&quot;特权&quot;会话，可以Relay 到 机子本身的Ews接口，然后可以使用SOAP请求头来冒充任何用户。</p><p><a href="https://github.com/WyAtu/CVE-2018-8581" target="_blank" rel="noopener noreferrer">脚本链接</a></p><p>思路2：获取域管权限</p><p>获取域管权限主要是利用dcsync进行dump hash后再进行横向移动，要使一个用户具有dcsync权限，只需要如下两条ACL</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&#39;DS-Replication-Get-Changes&#39;     = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2</span></span>
<span class="line"><span>&#39;DS-Replication-Get-Changes-All&#39; = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于邮件服务器<code>Exchange Windows Permissions</code>,<code>Exchange Trusted Subsystem</code>都具备Write-ACL的权限。其实<code>Exchange Trusted Subsystem</code>是<code>Exchange Windows Permissions</code> 组内成员，<code>Exchange Trusted Subsystem</code>的成员包括Exchange机器用户。</p><p>我们在拿到Exchange机器的http请求的时候，可以将请求Relay到Ldap,然后由于Exchange机器用户具备Write-ACL权限，我们在域内给添加两条acl，acl的受托人可以是任意用户从而使该用户具备Dcsync的权限。然后dump 域管的hash进行pth，dump kebtgt的hash进行黄金票据。</p></li><li><p>服务端是否要求签名</p><p>我们需要Relay到的是域控的ldap服务器，对于一个域环境，域控默认开启的签名是smb,ldap一直处于协商签名的模式，也就是说是否需要签名取决于我们的客户端，在exchange服务器上发起的是http请求，而http请求不需要签名。</p></li></ul><p>windows protocol上是通过ntlmralyx+priveexchange来为用户添加这两条ACL并dump hash，事实上可以采取集成化工具，相对会比较方便</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange (2).png" alt="exchange (2)" tabindex="0" loading="lazy"><figcaption>exchange (2)</figcaption></figure><p><a href="https://github.com/Ridter/Exchange2domain" target="_blank" rel="noopener noreferrer">工具链接</a>能够一键利用8581并dump hash</p><h2 id="cve-2019-1040" tabindex="-1"><a class="header-anchor" href="#cve-2019-1040"><span>CVE-2019-1040</span></a></h2><p>当中间人攻击者能够成功绕过 NTLM MIC（消息完整性检查）保护时，Microsoft Windows 中存在篡改漏洞。</p><ul><li><p>如何发起ntlm请求</p><p>之前讲到过利用打印机漏洞进行强制回连，后面觉得不太方便所以换了一个工具，回连变得简单多了。但是基本思路都相同，都通过强制回连来发起ntlm请求。不过拿到的net-ntlm-hash都是机器用户的hash.因此这里有两个思路，一是攻击exchange服务器，一个是直接攻击域管机器</p></li><li><p>拿到ntlm请求之后要做什么</p><p>上面已经说了，我们拿到的hash是机器用户的hash,并不能直接登录，因此不考虑relay到smb,考虑relay到ldap.显然，relay到ldap，如果我们攻击的是exchange服务器，那么我们就拥有了write acl的权限，能够用已控制的用户去dcsync了，那域管机器呢。</p><p>域管机器用户并不在域管理员组内，权限并不高，但我们可以联系之前提到过的基于资源的约束委派，再来回顾一下，基于资源的约束委派要求我们已经拥有一个服务/机器账户，并且获取服务2的ldap权限，通过设置基于资源的约束委派，我们就能掌控服务2.这里也是一样，我们relay到域控的ldap,并在域管机器MSDS-AllowedToActOnBehalfOfOtherIdentity里面添加一条ace，可以让任何机器用户和服务用户可以控制该用户(NTLM发起者)，虽然不能直接登录，但是因为该机器是域管机器，我们可以进行dcync。</p></li><li><p>服务端是否要求签名</p><p>不同于8581中以http的形式发起请求，如果通过打印机漏洞发起请求的话是smb协议。我们需要relay到ldap服务器，ldap默认处于协商签名模式，取决于客户端，而smb默认是要求签名的，这也是漏洞的核心，该漏洞绕过了MIC的校验。</p><p><a href="https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html" target="_blank" rel="noopener noreferrer">Wagging-the-Dog</a>这篇文章介绍的很详细</p><p>最新的绕过将NEGOTIATE_KEY_EXCHANGE和NEGOTIATE_VERSION位置为0，就不再检验MIC了。不像<code>msvAvFlag</code>那样参与Reponse的运算，因此置为0之后不仅不会校验mic，也不会使得Reponse校验出错。</p></li></ul><h3 id="相关利用" tabindex="-1"><a class="header-anchor" href="#相关利用"><span>相关利用</span></a></h3><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ntlmrelayx (2).png" alt="ntlmrelayx (2)" tabindex="0" loading="lazy"><figcaption>ntlmrelayx (2)</figcaption></figure><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/kali.png" alt="kali" tabindex="0" loading="lazy"><figcaption>kali</figcaption></figure><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/msds.png" alt="msds" tabindex="0" loading="lazy"><figcaption>msds</figcaption></figure><p>特别注意：虽然我们指定的攻击目标是10这台机器，实际上relay到的是我们的副域控40,这和relay到主域控没有什么区别</p><p>或许你会想尝试一键利用：<br><a href="https://github.com/Ridter/CVE-2019-1040" target="_blank" rel="noopener noreferrer">CVE-2019-1040</a></p><p>很显然这个脚本仅支持邮件服务器存在的情况</p><h2 id="cve-2019-1384" tabindex="-1"><a class="header-anchor" href="#cve-2019-1384"><span>CVE-2019-1384</span></a></h2><p>绕过了MS08-068对lsass缓存的检测，这是因为补丁对lsass缓存中的chanllege是有时效性的，当超过5分钟后，缓存就会被释放，这时就没人管A和B是否是同一台主机，poc通过在315秒之后再relay避免了这个问题</p><p><a href="https://shenaniganslabs.io/files/impacket-ghostpotato.zip" target="_blank" rel="noopener noreferrer">poc</a></p><p>要求：</p><p>用户必须是本地管理员组的成员</p><p>用户必须是 Backup Operators 组的成员</p><p>令牌必须提升</p>`,62)]))}const o=i(n,[["render",l],["__file","相关漏洞.html.vue"]]),c=JSON.parse('{"path":"/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/NTLM%E4%B8%93%E9%A2%98/%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E.html","title":"相关漏洞","lang":"zh-CN","frontmatter":{"description":"相关漏洞 这一篇主要是对现有的部分漏洞进行复现，以及部分相关细节的补充，之后新的漏洞也就不会补充到这篇里面了 MS08-068 当用户拿到smb请求之后，最直接的就是把请求relay回本身，即Reflect.从而控制机器本身。 微软在kb957097补丁里面通过修改SMB身份验证答复的验证方式来防止凭据重播，从而解决了该漏洞。 微软所做的措施如下， 主...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/NTLM%E4%B8%93%E9%A2%98/%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"相关漏洞"}],["meta",{"property":"og:description","content":"相关漏洞 这一篇主要是对现有的部分漏洞进行复现，以及部分相关细节的补充，之后新的漏洞也就不会补充到这篇里面了 MS08-068 当用户拿到smb请求之后，最直接的就是把请求relay回本身，即Reflect.从而控制机器本身。 微软在kb957097补丁里面通过修改SMB身份验证答复的验证方式来防止凭据重播，从而解决了该漏洞。 微软所做的措施如下， 主..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ms08-068.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"相关漏洞\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ms08-068.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/exchange%20(2\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/ntlmrelayx%20(2\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/kali.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/main/ntlm/msds.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"MS08-068","slug":"ms08-068","link":"#ms08-068","children":[]},{"level":2,"title":"CVE-2015-0005","slug":"cve-2015-0005","link":"#cve-2015-0005","children":[{"level":3,"title":"漏洞成因","slug":"漏洞成因","link":"#漏洞成因","children":[]},{"level":3,"title":"NETLOGON 步骤","slug":"netlogon-步骤","link":"#netlogon-步骤","children":[]},{"level":3,"title":"漏洞利用","slug":"漏洞利用","link":"#漏洞利用","children":[]}]},{"level":2,"title":"MS16-075(HotPotato)","slug":"ms16-075-hotpotato","link":"#ms16-075-hotpotato","children":[]},{"level":2,"title":"CVE-2018-8581","slug":"cve-2018-8581","link":"#cve-2018-8581","children":[]},{"level":2,"title":"CVE-2019-1040","slug":"cve-2019-1040","link":"#cve-2019-1040","children":[{"level":3,"title":"相关利用","slug":"相关利用","link":"#相关利用","children":[]}]},{"level":2,"title":"CVE-2019-1384","slug":"cve-2019-1384","link":"#cve-2019-1384","children":[]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":9.08,"words":2725},"filePathRelative":"渗透测试/NTLM专题/相关漏洞.md","localizedDate":"2025年1月16日","excerpt":"\\n<p>这一篇主要是对现有的部分漏洞进行复现，以及部分相关细节的补充，之后新的漏洞也就不会补充到这篇里面了</p>\\n<h2>MS08-068</h2>\\n<p>当用户拿到smb请求之后，最直接的就是把请求relay回本身，即Reflect.从而控制机器本身。</p>\\n<p>微软在kb957097补丁里面通过修改SMB身份验证答复的验证方式来防止凭据重播，从而解决了该漏洞。</p>\\n<p>微软所做的措施如下，</p>\\n<p>主机A向主机B(访问\\\\B)进行SMB认证的时候，将<em>pszTargetName</em>设置为<code>cifs/B</code>,然后在type 2拿到主机B发送Challenge之后，在lsass里面缓存(Challenge,<code>cifs/B</code>)。</p>","autoDesc":true}');export{o as comp,c as data};
